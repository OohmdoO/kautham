/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2011 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 
 
#include "pathtoguide.h"

namespace libGuiding{

  PathToGuide::PathToGuide( Robot &rob ):_rob(rob){
    unsigned int i = 0;
    _pathQ.clear();
    _pathX.clear();
    _nearestQ = NULL;
    _nearestX = NULL;

    vector<RobConf>::iterator it;
    mt::Point3 pos;
    mt::Rotation rot;
    mt::Transform trans;
    Xnode anXnode( 7 );
    Qnode anQnode( _rob.getNumJoints() );

    i = 0;
    for(it = _rob.getProposedSolution().begin(); it != _rob.getProposedSolution().end(); ++it){
      // For each item, the algorithm extracts the Q configuration and stores it in the 
      // _pathQ and then it will be converted to the TCP cartesian position with the 
      // inverse kinematic and it will be stored in the _pathX.

      std::copy(it->second.getCoordinates().begin(), it->second.getCoordinates().end(), anQnode.begin() );

      _rob.Kinematics(*it);
      trans = _rob.getLastLinkTransform();
      pos = trans.getTranslation();
      rot = trans.getRotation();

      for( i = 0; i < 3; i++){
        anXnode.at(i) = pos.at(i);
        anXnode.at(i+3) = rot.at(i);
      }
      anXnode.at(6) = rot.at(3);

      _pathQ.push_back( anQnode );
      _pathX.push_back( anXnode );
    }  

    if( _pathQ.size() == _pathX.size() && _pathQ.size() != 0 ){
      recalculateANN();
    }
  }  

  PathToGuide::PathToGuide( Robot* rob ):_rob(*rob){
    unsigned int i = 0;
    _pathQ.clear();
    _pathX.clear();
    _nearestQ = NULL;
    _nearestX = NULL;

    vector<RobConf>::iterator it;
    mt::Point3 pos;
    mt::Rotation rot;
    mt::Transform trans;
    Xnode anXnode( 7 );
    Qnode anQnode( _rob.getNumJoints() );

    i = 0;
    for(it = _rob.getProposedSolution().begin(); it != _rob.getProposedSolution().end(); ++it){
      // For each item, the algorithm extracts the Q configuration and stores it in the 
      // _pathQ and then it will be converted to the TCP cartesian position with the 
      // inverse kinematic and it will be stored in the _pathX.

      std::copy(it->second.getCoordinates().begin(), it->second.getCoordinates().end(), anQnode.begin() );

      _rob.Kinematics(*it);
      trans = _rob.getLastLinkTransform();
      pos = trans.getTranslation();
      rot = trans.getRotation();

      for( i = 0; i < 3; i++){
        anXnode.at(i) = pos.at(i);
        anXnode.at(i+3) = rot.at(i);
      }
      anXnode.at(6) = rot.at(3);

      _pathQ.push_back( anQnode );
      _pathX.push_back( anXnode );
    }  

    if( _pathQ.size() == _pathX.size() && _pathQ.size() != 0 ){
      recalculateANN();
    }
  }


  void PathToGuide::recalculateANN(){
    if( _nearestQ != NULL ){
      delete _nearestQ;
      annDeallocPts(_ptsQ);
    }

    if( _nearestX != NULL ) {
      delete _nearestX;
      annDeallocPts(_ptsX);
    }

    // First setup the Q structure.
    int dim = _pathQ.at(0).size();
		int *topology = new int[dim];
		double *scale = new double[dim];

		for(unsigned int k = 0; k < dim ; k++){
			topology[k] = 1; //Rn 
			scale[k] = _rob.getLink(k+1)->getWeight();  
		}
		

    _nearestQ = new MultiANN(dim, _pathQ.size(), topology, scale);	// create a data structure	
		_ptsQ = annAllocPts(_pathQ.size(), dim);		// allocate data points

    // Copying data
    for(unsigned int i = 0; i < _pathQ.size();++i)
      for(unsigned int k = 0; k < _rob.getNumJoints(); k++)
		    _ptsQ[i][k] = _pathQ.at(i).at(k);

    //XXXXXXXXXXXXXXXXX

    delete topology;
    delete scale;

    topology = new int[7];
		scale = new double[7];
		int c=0;
    double rho_t = 1.0;
    double rho_r = 1.0;  

		topology[c] = 1; //x
		scale[c++] = rho_t;  
		topology[c] = 1; //y
		scale[c++] =  rho_t;  
		topology[c] = 1; //z
		scale[c++] =  rho_t;  

		topology[c] = 3; //quaternion
		scale[c++] = rho_r;  
		topology[c] = 3; //quaternion
		scale[c++] = rho_r;  
		topology[c] = 3; //quaternion
		scale[c++] = rho_r;  
		topology[c] = 3; //quaternion
		scale[c++] = rho_r;  

    _nearestX = new MultiANN(7, _pathX.size(), topology, scale);	// create a data structure	
		_ptsX = annAllocPts(_pathX.size(), 7);		// allocate data points

    //XXXXXXXXXXX  Copying data  XXXXXXX
    for(unsigned int i = 0; i < _pathX.size();++i)
      for(unsigned int k = 0; k < _rob.getNumJoints(); k++)
		    _ptsX[i][k] = _pathX.at(i).at(k);

    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

  }

  int PathToGuide::nearQ(const Qnode &qn ){
		double d_ann = 0.;
		int idx_ann = 0;
		//ANNpoint *result_pt = new ANNpoint;
    ANNpoint pts = annAllocPt( qn.size() );

    std::copy(qn.begin(), qn.end(), pts );
    
    // compute nearest neighbor using library
		_nearestQ->NearestNeighbor(pts, idx_ann, d_ann );// (void**&)result_pt);	

    return idx_ann;
  }

  void PathToGuide::nearQ(const Qnode &qn, Qnode& res ){
    int idx = nearQ( qn );
    res = _pathQ.at( idx );
  }

  int PathToGuide::nearX(const Xnode &xn ){
    double d_ann = 0.;
		int idx_ann = 0;
		//ANNpoint *result_pt = new ANNpoint;
    ANNpoint pts = annAllocPt( xn.size() );

    std::copy(xn.begin(), xn.end(), pts );
    
    // compute nearest neighbor using library
		_nearestX->NearestNeighbor(pts, idx_ann, d_ann );// (void**&)result_pt);	

    return idx_ann;
  }

  void PathToGuide::nearX(const Xnode &xn, Xnode& res ){
    int idx = nearX( xn );
    res = _pathX.at( idx );
  }
}
