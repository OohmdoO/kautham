/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2011 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 
 
#include "pathtoguide.h"

namespace libGuiding{

  PathToGuide::PathToGuide( Robot &rob ):_rob(rob){
    unsigned int i = 0;
    _pathQ.clear();
    _pathX.clear();
    _nearestQ = NULL;
    _nearestX = NULL;

    vector<RobConf>::iterator it;
    mt::Transform trans;
    Xnode anXnode( 7 );
    Qnode anQnode( _rob.getNumJoints() );

    i = 0;
    for(it = _rob.getProposedSolution().begin(); it != _rob.getProposedSolution().end(); ++it){
      // For each item, the algorithm extracts the Q configuration and stores it in the 
      // _pathQ and then it will be converted to the TCP cartesian position with the 
      // inverse kinematic and it will be stored in the _pathX.

      std::copy(it->second.getCoordinates().begin(), it->second.getCoordinates().end(), anQnode.begin() );

      _rob.Kinematics(*it);
      trans = _rob.getLastLinkTransform();
      anXnode = tran2xnode(trans);

      _pathQ.push_back( anQnode );
      _pathX.push_back( anXnode );
    }  

    if( _pathQ.size() == _pathX.size() && _pathQ.size() != 0 ){
      recalculateANN();
    }
  }  

  PathToGuide::PathToGuide( Robot* rob ):_rob(*rob){
    unsigned int i = 0;
    _pathQ.clear();
    _pathX.clear();
    _nearestQ = NULL;
    _nearestX = NULL;

    vector<RobConf>::iterator it;
    mt::Transform trans;
    Xnode anXnode( 7 );
    Qnode anQnode( _rob.getNumJoints() );

    i = 0;
    for(it = _rob.getProposedSolution().begin(); it != _rob.getProposedSolution().end(); ++it){
      // For each item, the algorithm extracts the Q configuration and stores it in the 
      // _pathQ and then it will be converted to the TCP cartesian position with the 
      // inverse kinematic and it will be stored in the _pathX.

      std::copy(it->second.getCoordinates().begin(), it->second.getCoordinates().end(), anQnode.begin() );

      _rob.Kinematics(*it);
      trans = _rob.getLastLinkTransform();
      anXnode = tran2xnode(trans);

      _pathQ.push_back( anQnode );
      _pathX.push_back( anXnode );
    }  

    if( _pathQ.size() == _pathX.size() && _pathQ.size() != 0 ){
      recalculateANN();
    }
  }

  KthReal PathToGuide::magVector(Qnode &qi, Uvec &um, Qnode &qd ){
    return 0.;
  }

  void PathToGuide::pushVectorQ( Qnode &qd, Uvec &up ){

  }

  KthReal PathToGuide::magVector(Xnode &xi, Uvec &um, Xnode &xd, int k, KthReal ratio ){
    return 0.;
  }

  void PathToGuide::pushVectorX( Xnode &qd, Uvec &up ){

  }

 int PathToGuide::nearQ(const Qnode &qn ){
		double d_ann = 0.;
		int idx_ann = 0;
		//ANNpoint *result_pt = new ANNpoint;
    ANNpoint pts = annAllocPt( qn.size() );

    std::copy(qn.begin(), qn.end(), pts );
    
    // compute nearest neighbor using library
		_nearestQ->NearestNeighbor(pts, idx_ann, d_ann );// (void**&)result_pt);	

    return idx_ann;
  }

  bool PathToGuide::nearQ(const Qnode &qn, int* indexs ){
    try{
      indexs[0] = indexs[1] = -1;

      double *d_ann = new double[2];
		  ANNpoint *result_pt = new ANNpoint[2];

      ANNpoint pts = annAllocPt( qn.size() );
      std::copy(qn.begin(), qn.end(), pts );
  		
		  d_ann[0] = d_ann[1] = INFINITY;

      // compute nearest neighbor using library
      _nearestQ->NearestNeighbor(pts, d_ann, indexs, (void**&)result_pt);	
      return true;
    }catch(...){
      return false;
    }
  }

  void PathToGuide::nearQ(const Qnode &qn, Qnode& res ){
    int idx = nearQ( qn );
    res = _pathQ.at( idx );
  }

  bool PathToGuide::nearQ(const Qnode &qn, Qnode res[] ){
    try{
      int idx[]={-1, -1};
      res[0].clear();
      res[1].clear();

      nearQ(qn, idx);
      res[0] = _pathQ.at(idx[0]);
      res[1] = _pathQ.at(idx[1]);
      return true;
    }catch(...){
      return false;
    }
  }

  int PathToGuide::nearX(const Xnode &xn ){
    double d_ann = 0.;
		int idx_ann = 0;
		//ANNpoint *result_pt = new ANNpoint;
    ANNpoint pts = annAllocPt( xn.size() );

    std::copy(xn.begin(), xn.end(), pts );
    
    // compute nearest neighbor using library
		_nearestX->NearestNeighbor(pts, idx_ann, d_ann );// (void**&)result_pt);	

    return idx_ann;
  }

  bool PathToGuide::nearX(const Xnode &xn, int* indexs ){
    try{
      indexs[0] = indexs[1] = -1;

      double *d_ann = new double[2];
		  ANNpoint *result_pt = new ANNpoint[2];

      ANNpoint pts = annAllocPt( xn.size() );
      std::copy(xn.begin(), xn.end(), pts );
  		
		  d_ann[0] = d_ann[1] = INFINITY;

      // compute nearest neighbor using library
      _nearestX->NearestNeighbor(pts, d_ann, indexs, (void**&)result_pt);	
      return true;
    }catch(...){
      return false;
    }
  }

  void PathToGuide::nearX(const Xnode &xn, Xnode& res ){
    int idx = nearX( xn );
    res = _pathX.at( idx );
  }

  bool PathToGuide::nearX(const Xnode &xn, Xnode res[] ){
    try{
      int idx[]={-1, -1};
      res[0].clear();
      res[1].clear();

      nearX(xn, idx);
      res[0] = _pathX.at(idx[0]);
      res[1] = _pathX.at(idx[1]);
      return true;
    }catch(...){
      return false;
    }
  }
  
  void PathToGuide::recalculateANN(){
    if( _nearestQ != NULL ){
      delete _nearestQ;
      annDeallocPts(_ptsQ);
    }

    if( _nearestX != NULL ) {
      delete _nearestX;
      annDeallocPts(_ptsX);
    }

    // First setup the Q structure.
    int dim = _pathQ.at(0).size();
		int *topology = new int[dim];
		double *scale = new double[dim];

		for(unsigned int k = 0; k < dim ; k++){
			topology[k] = 1; //Rn 
			scale[k] = _rob.getLink(k+1)->getWeight();  
		}
		

    _nearestQ = new MultiANN(dim, _pathQ.size(), topology, scale);	// create a data structure	
		_ptsQ = annAllocPts(_pathQ.size(), dim);		// allocate data points

    // Copying data
    for(unsigned int i = 0; i < _pathQ.size();++i)
      for(unsigned int k = 0; k < _rob.getNumJoints(); k++)
		    _ptsQ[i][k] = _pathQ.at(i).at(k);

    //XXXXXXXXXXXXXXXXX

    delete topology;
    delete scale;

    topology = new int[7];
		scale = new double[7];
		int c=0;
    double rho_t = 1.0;
    double rho_r = 1.0;  

		topology[c] = 1; //x
		scale[c++] = rho_t;  
		topology[c] = 1; //y
		scale[c++] =  rho_t;  
		topology[c] = 1; //z
		scale[c++] =  rho_t;  

		topology[c] = 3; //quaternion
		scale[c++] = rho_r;  
		topology[c] = 3; //quaternion
		scale[c++] = rho_r;  
		topology[c] = 3; //quaternion
		scale[c++] = rho_r;  
		topology[c] = 3; //quaternion
		scale[c++] = rho_r;  

    _nearestX = new MultiANN(7, _pathX.size(), topology, scale);	// create a data structure	
		_ptsX = annAllocPts(_pathX.size(), 7);		// allocate data points

    //XXXXXXXXXXX  Copying data  XXXXXXX
    for(unsigned int i = 0; i < _pathX.size();++i)
      for(unsigned int k = 0; k < _rob.getNumJoints(); k++)
		    _ptsX[i][k] = _pathX.at(i).at(k);

    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  }

 
}
