/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 

#if defined(KAUTHAM_USE_OMPL)

#include <libproblem/workspace.h>
#include <libsampling/sampling.h>

#include <boost/bind/mem_fn.hpp>

#include "localplanner.h"
#include "omplcplanner.h"
#include "omplplanner.h"


#include <extensions/opende/OpenDESimpleSetup.h>
#include <ode/ode.h>
#include <ompl/config.h>


using namespace libSampling;



namespace libPlanner {
  namespace omplcplanner{

  /////////////////////////////////////////////////////////////////////////////////////////////////
  // AUXILIAR functions
  /////////////////////////////////////////////////////////////////////////////////////////////////

  /////////////////////////////////////////////////////////////////////////////////////////////////
  //! This function converts a state to a smp and tests if it is in collision or not
  bool isStateValid(const oc::SpaceInformation *si, const ob::State *state, Planner *p)
  {
      if(  si->satisfiesBounds(state)==false )
          return false;
      //create sample
      int d = p->wkSpace()->getDimension();
      Sample *smp = new Sample(d);
      //copy the conf of the init smp. Needed to capture the home positions.
      smp->setMappedConf(p->initSamp()->getMappedConf());
      //load the RobConf of smp form the values of the ompl::state
      ((omplcPlanner*)p)->omplState2smp(state,smp);
      //collision-check
      if( p->wkSpace()->collisionCheck(smp) )
          return false;
      return true;
  }




    //! Constructor
    omplOpenDEPlanner::omplOpenDEPlanner(SPACETYPE stype, Sample *init, Sample *goal, SampleSet *samples, Sampler *sampler, WorkSpace *ws, LocalPlanner *lcPlan, KthReal ssize):
              Planner(stype, init, goal, samples, sampler, ws, lcPlan, ssize)
    {
        //set intial values from parent class data
        _speedFactor = 1;
        _stepSize = ssize;
        _solved = false;
        _guiName = "omplOpenDE Planner";
        _idName = "omplOpenDE Planner";

        //set own intial values
        _planningTime = 10;

        //add planner parameters
        addParameter("Max Planning Time", _planningTime);
        addParameter("Step Size", ssize);
        addParameter("Speed Factor", _speedFactor);

        //Construct the state space we are planning in.



    }

	//! void destructor
    omplOpenDEPlanner::~omplOpenDEPlanner(){
			
	}
	


	//! setParameters sets the parameters of the planner
    bool omplOpenDEPlanner::setParameters(){
      try{
        HASH_S_K::iterator it = _parameters.find("Speed Factor");
        if(it != _parameters.end())
          _speedFactor = it->second;
        else
          return false;

        it = _parameters.find("Max Planning Time");
        if(it != _parameters.end())
            _planningTime = it->second;
        else
          return false;

      }catch(...){
        return false;
      }
      return true;
    }


	//! function to find a solution path
    bool omplOpenDEPlanner::trySolve()
    {
        //Start state: convert from smp to scoped state
        ob::ScopedState<ob::CompoundStateSpace> startompl(space);
        smp2omplScopedState(_init, &startompl);
        cout<<"startompl:"<<endl;
        startompl.print();

        //Goal state: convert from smp to scoped state
        ob::ScopedState<ob::CompoundStateSpace> goalompl(space);
        smp2omplScopedState(_goal, &goalompl);
        cout<<"goalompl:"<<endl;
        goalompl.print();

        // set the start and goal states
        // set a threshold to reach the goal - should it be set as a planner parameter?
        ss->setStartAndGoalStates(startompl, goalompl, 0.01);

        // attempt to solve the problem within _planningTime seconds of planning time
        ss->clear();//to remove previous solutions, if any
        ss->getPlanner()->clear();
        ob::PlannerStatus solved = ss->solve(_planningTime);

         ss->print();

        //retrieve all the states. Load the SampleSet _samples
        Sample *smp;
        ob::PlannerData data(ss->getSpaceInformation());
        ss->getPlannerData(data);

        if (solved)
        {
             std::cout << "Found solution (solved=<<"<<solved.asString()<<"):" << std::endl;
             // print the path to screen
             std::cout << "Geomeric Path solution:" << std::endl;
             ss->getSolutionPath().asGeometric().print(std::cout);
             std::cout << "Control Path solution:" << std::endl;
             ss->getSolutionPath().print(std::cout);

             //retrieve the geometric path
             std::vector< ob::State * > & pathstates = ss->getSolutionPath().asGeometric().getStates();

             Sample *smp;
             _path.clear();
             clearSimulationPath();
             int l = ss->getSolutionPath().asGeometric().getStateCount();

             //load the kautham _path variable from the ompl solution
             for(int j=0;j<l;j++){
                 //create a smp and load the RobConf of the init configuration (to have the same if the state does not changi it)
                 smp=new Sample(_wkSpace->getDimension());
                 smp->setMappedConf(_init->getMappedConf());
                 //convert form state to smp
                 omplState2smp(ss->getSolutionPath().asGeometric().getState(j)->as<ob::CompoundStateSpace::StateType>(), smp);

                 _path.push_back(smp);
                 _samples->add(smp);
               }
               _solved = true;
               drawCspace();
               return _solved;
            }
            else{
                std::cout << "No solution found (solved=<<"<<solved.asString()<<")" << std::endl;
                _solved = false;
                drawCspace();
                return _solved;
            }
		}
    }
}

#endif // KAUTHAM_USE_OMPL


