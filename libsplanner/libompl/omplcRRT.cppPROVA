/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
#if defined(KAUTHAM_USE_OMPL)


#include "ompl/base/goals/GoalSampleableRegion.h"
#include "ompl/tools/config/SelfConfig.h"
#include <limits>
#include "omplcRRT.h"


namespace libPlanner {
  namespace omplcplanner{


      ob::PlannerStatus myRRT::solve(const ob::PlannerTerminationCondition &ptc)
      {
          checkValidity();
          ob::Goal                   *goal = pdef_->getGoal().get();
          ob::GoalSampleableRegion *goal_s = dynamic_cast<ob::GoalSampleableRegion*>(goal);

          while (const ob::State *st = pis_.nextStart())
          {
              Motion *motion = new Motion(siC_);
              si_->copyState(motion->state, st);
              siC_->nullControl(motion->control);
              nn_->add(motion);
          }

          if (nn_->size() == 0)
          {
              OMPL_ERROR("There are no valid initial states!");
              return ob::PlannerStatus::INVALID_START;
          }

          if (!sampler_)
              sampler_ = si_->allocStateSampler();
          if (!controlSampler_)
              controlSampler_ = siC_->allocDirectedControlSampler();

          OMPL_INFORM("Starting with %u states", nn_->size());

          Motion *solution  = NULL;
          Motion *approxsol = NULL;
          double  approxdif = std::numeric_limits<double>::infinity();

          Motion      *rmotion = new Motion(siC_);
          ob::State  *rstate = rmotion->state;
          oc::Control       *rctrl = rmotion->control;
          ob::State  *xstate = si_->allocState();

          while (ptc == false)
          {
              /* sample random state (with goal biasing) */
              if (goal_s && rng_.uniform01() < goalBias_ && goal_s->canSample())
                  goal_s->sampleGoal(rstate);
              else
                  sampler_->sampleUniform(rstate);

              /* find closest state in the tree */
              Motion *nmotion = nn_->nearest(rmotion);

              /* sample a random control that attempts to go towards the random state, and also sample a control duration */
              unsigned int cd = controlSampler_->sampleTo(rctrl, nmotion->control, nmotion->state, rmotion->state);

              if (addIntermediateStates_)
              {
                  // this code is contributed by Jennifer Barry
                  std::vector<ob::State *> pstates;
                  cd = siC_->propagateWhileValid(nmotion->state, rctrl, cd, pstates, true);

                  if (cd >= siC_->getMinControlDuration())
                  {
                      Motion *lastmotion = nmotion;
                      bool solved = false;
                      size_t p = 0;
                      for ( ; p < pstates.size(); ++p)
                      {
                          /* create a motion */
                          Motion *motion = new Motion();
                          motion->state = pstates[p];
                          //we need multiple copies of rctrl
                          motion->control = siC_->allocControl();
                          siC_->copyControl(motion->control, rctrl);
                          motion->steps = 1;
                          motion->parent = lastmotion;
                          lastmotion = motion;
                          nn_->add(motion);
                          double dist = 0.0;
                          solved = goal->isSatisfied(motion->state, &dist);
                          if (solved)
                          {
                              approxdif = dist;
                              solution = motion;
                              break;
                          }
                          if (dist < approxdif)
                          {
                              approxdif = dist;
                              approxsol = motion;
                          }
                      }

                      //free any states after we hit the goal
                      while (++p < pstates.size())
                          si_->freeState(pstates[p]);
                      if (solved)
                          break;
                  }
                  else
                      for (size_t p = 0 ; p < pstates.size(); ++p)
                          si_->freeState(pstates[p]);
              }
              else
              {
                  cd = siC_->propagateWhileValid(nmotion->state, rctrl, cd, xstate);

                  if (cd >= siC_->getMinControlDuration())
                  {
                      /* create a motion */
                      Motion *motion = new Motion(siC_);
                      si_->copyState(motion->state, xstate);
                      siC_->copyControl(motion->control, rctrl);
                      motion->steps = cd;
                      motion->parent = nmotion;

                      nn_->add(motion);
                      double dist = 0.0;
                      bool solv = goal->isSatisfied(motion->state, &dist);
                      if (solv)
                      {
                          approxdif = dist;
                          solution = motion;
                          break;
                      }
                      if (dist < approxdif)
                      {
                          approxdif = dist;
                          approxsol = motion;
                      }
                  }
              }
          }

          bool solved = false;
          bool approximate = false;
          if (solution == NULL)
          {
              solution = approxsol;
              approximate = true;
          }

          if (solution != NULL)
          {
              lastGoalMotion_ = solution;

              /* construct the solution path */
              std::vector<Motion*> mpath;
              while (solution != NULL)
              {
                  mpath.push_back(solution);
                  solution = solution->parent;
              }

              /* set the solution path */
              oc::PathControl *path = new oc::PathControl(si_);
              for (int i = mpath.size() - 1 ; i >= 0 ; --i)
                  if (mpath[i]->parent)
                      path->append(mpath[i]->state, mpath[i]->control, mpath[i]->steps * siC_->getPropagationStepSize());
                  else
                      path->append(mpath[i]->state);
              solved = true;
              pdef_->addSolutionPath(ob::PathPtr(path), approximate, approxdif);
          }

          if (rmotion->state)
              si_->freeState(rmotion->state);
          if (rmotion->control)
              siC_->freeControl(rmotion->control);
          delete rmotion;
          si_->freeState(xstate);

          OMPL_INFORM("Created %u states", nn_->size());

          return ob::PlannerStatus(solved, approximate);
      }

  }
}

#endif // KAUTHAM_USE_OMPL
