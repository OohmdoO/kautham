/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 

#if defined(KAUTHAM_USE_OMPL)

#include <libproblem/workspace.h>
#include <libsampling/sampling.h>

#include <boost/bind/mem_fn.hpp>

#include "omplplanner.h"


#include <Inventor/nodes/SoTransform.h>
#include <Inventor/nodes/SoCoordinate3.h>
#include <Inventor/nodes/SoCube.h>
#include <Inventor/nodes/SoPointSet.h>
#include <Inventor/nodes/SoLineSet.h>

#include <ompl/base/ProblemDefinition.h>
//#include <ompl/base/OptimizationObjective.h>
//#include <ompl/base/objectives/PathLengthOptimizationObjective.h>
//#include <ompl/base/objectives/MaximizeMinClearanceObjective.h>

namespace Kautham {
/** \addtogroup libPlanner
 *  @{
 */

//! Namespace omplplanner contains the planners based on the OMPL::geometric library
  namespace omplplanner{

  //declaration of class
  class weightedRealVectorStateSpace;


  /////////////////////////////////////////////////////////////////////////////////////////////////
  // weigthedRealVectorStateSpace functions
  /////////////////////////////////////////////////////////////////////////////////////////////////
      //! The constructor initializes all the weights to 1
      weigthedRealVectorStateSpace::weigthedRealVectorStateSpace(unsigned int dim) : RealVectorStateSpace(dim)
      {
          //by default set all the weights to 1
          for(int i=0; i<dim; i++)
          {
              weights.push_back(1.0);
          }
      }

      //! The destructor
      weigthedRealVectorStateSpace::~weigthedRealVectorStateSpace(void){}


      //! This function sets the values of the weights. The values passed as a parameter are scaled in order not to change the maximim extend of the space
      void weigthedRealVectorStateSpace::setWeights(vector<KthReal> w)
      {
          double fitFactor;

          //compute the maximum weigthed distance
          double maxweightdist=0.0;
          for(int i=0; i<dimension_; i++)
          {
              double diff = getBounds().getDifference()[i]*w[i];
              maxweightdist += diff * diff;
          }
          maxweightdist = sqrt(maxweightdist);
          //compute the scale factor
          fitFactor = getMaximumExtent()/maxweightdist;
          //set the weights
          for(int i=0; i<dimension_; i++)
          {
              weights[i] = w[i]*fitFactor;
          }
      }

      //! This function computes the weighted distance between states
      double weigthedRealVectorStateSpace::distance(const ob::State *state1, const ob::State *state2) const
      {
         double dist = 0.0;
         const double *s1 = static_cast<const StateType*>(state1)->values;
         const double *s2 = static_cast<const StateType*>(state2)->values;

        for (unsigned int i = 0 ; i < dimension_ ; ++i)
        {
            double diff = ((*s1++) - (*s2++))*weights[i];
            dist += diff * diff;
        }
        return sqrt(dist);
      }



  /////////////////////////////////////////////////////////////////////////////////////////////////
  // KauthamStateSampler functions
  /////////////////////////////////////////////////////////////////////////////////////////////////
      KauthamStateSampler::KauthamStateSampler(const ob::StateSpace *sspace, Planner *p) : ob::CompoundStateSampler(sspace)
      {
          kauthamPlanner_ = p;
          centersmp = NULL;
      }

      void KauthamStateSampler::setCenterSample(ob::State *state, double th)
      {
          if(state!=NULL)
          {
            //create sample
            int d = kauthamPlanner_->wkSpace()->getDimension();
            centersmp = new Sample(d);
            //copy the conf of the init smp. Needed to capture the home positions.
            centersmp->setMappedConf(kauthamPlanner_->initSamp()->getMappedConf());
            //load the RobConf of smp form the values of the ompl::state
            ((omplPlanner*)kauthamPlanner_)->omplState2smp(state,centersmp);
          }
          else
              centersmp = NULL;

          //initialize threshold
          threshold = th;
      }      

      void KauthamStateSampler::sampleUniform(ob::State *state)
      {
          //Sample around centersmp
          //this does the same as sampleUniformNear, but the Near configuration is set beforehand as "centersmp" configuration.
          //this has been added to modify the behavior of the randombounce walk of the PRM. It used the sampleUniform and
          //we wanted to use the sampleUniformNear
          if(centersmp != NULL && threshold > 0.0)
          {
            int trials = 0;
            int maxtrials=100;
            bool found = false;
            int d = kauthamPlanner_->wkSpace()->getDimension();
            Sample *smp = new Sample(d);
            double dist;

            do{
                //sample the kautham control space. Controls are defined in the input xml files. Eeach control value lies in the [0,1] interval
                vector<KthReal> coords(d);
                for(int i=0;i<d;i++)
                    coords[i] = rng_.uniformReal(0,1.0);

                //load the obtained coords to a sample, and compute the mapped configurations (i.e.se3+Rn values) by calling MoveRobotsto function.
                smp->setCoords(coords);
                kauthamPlanner_->wkSpace()->moveRobotsTo(smp);

                dist = kauthamPlanner_->wkSpace()->distanceBetweenSamples(*smp,*centersmp,CONFIGSPACE);
                if(dist < threshold)
                    found = true;
                trials ++;
            }while(found==false && trials <maxtrials);


            ob::ScopedState<ob::CompoundStateSpace> sstate(  ((omplPlanner*)kauthamPlanner_)->getSpace() );
            if(trials==maxtrials)
            {
                //not found within the limits. return the centersmp
                ((omplPlanner*)kauthamPlanner_)->smp2omplScopedState(centersmp, &sstate);
            }
            else
            {
                //convert the sample found to scoped state
                ((omplPlanner*)kauthamPlanner_)->smp2omplScopedState(smp, &sstate);
            }

            //return in parameter state
            ((omplPlanner*)kauthamPlanner_)->getSpace()->copyState(state, sstate.get());
         }
        //sample the whole workspace
         else
         {
              //sample the kautham control space. Controls are defined in the input xml files. Eeach control value lies in the [0,1] interval
              int d = kauthamPlanner_->wkSpace()->getDimension();
              vector<KthReal> coords(d);
              for(int i=0;i<d;i++)
                  coords[i] = rng_.uniformReal(0,1.0);

              //load the obtained coords to a sample, and compute the mapped configurations (i.e.se3+Rn values) by calling MoveRobotsto function.
              Sample *smp = new Sample(d);
              smp->setCoords(coords);
              kauthamPlanner_->wkSpace()->moveRobotsTo(smp);

              //convert from sample to scoped state
              ob::ScopedState<ob::CompoundStateSpace> sstate(  ((omplPlanner*)kauthamPlanner_)->getSpace() );
              ((omplPlanner*)kauthamPlanner_)->smp2omplScopedState(smp, &sstate);

              //return in parameter state
             ((omplPlanner*)kauthamPlanner_)->getSpace()->copyState(state, sstate.get());
         }

      }


      void KauthamStateSampler::sampleUniformNear(ob::State *state, const ob::State *near, const double distance)
           {
               int trials = 0;
               int maxtrials=100;
               bool found = false;
               do{
                 //sample the kautham control space. Controls are defined in the input xml files. Eeach control value lies in the [0,1] interval
                 int d = kauthamPlanner_->wkSpace()->getDimension();
                 vector<KthReal> coords(d);
                 for(int i=0;i<d;i++)
                     coords[i] = rng_.uniformReal(0,1.0);
                 //load the obtained coords to a sample, and compute the mapped configurations (i.e.se3+Rn values) by calling MoveRobotsto function.
                 Sample *smp = new Sample(d);
                 smp->setCoords(coords);
                 kauthamPlanner_->wkSpace()->moveRobotsTo(smp);
                 //convert from sample to scoped state
                 ob::ScopedState<ob::CompoundStateSpace> sstate(  ((omplPlanner*)kauthamPlanner_)->getSpace() );
                 ((omplPlanner*)kauthamPlanner_)->smp2omplScopedState(smp, &sstate);
                 //return the stae in the parameter state and a bool telling if the smp is in collision or not
                 ((omplPlanner*)kauthamPlanner_)->getSpace()->copyState(state, sstate.get());
                 if (((omplPlanner*)kauthamPlanner_)->getSpace()->distance(state,near)> distance)
                     found = false;
                 else
                     found=true;
                  trials ++;
               }while(found==false && trials <maxtrials);

                if (!found){
                ((omplPlanner*)kauthamPlanner_)->getSpace()->copyState(state, near);
                }


               //throw ompl::Exception("KauthamValidStateSampler::sampleNear", "not implemented");
               //return false;
           }


  /////////////////////////////////////////////////////////////////////////////////////////////////
  // KauthamValidStateSampler functions
  /////////////////////////////////////////////////////////////////////////////////////////////////
      //! Creator. The parameter samplername is defaulted to "Random" and the value to "0.0
      KauthamValidStateSampler::KauthamValidStateSampler(const ob::SpaceInformation *si, Planner *p) : ob::ValidStateSampler(si)
      {
          name_ = "kautham sampler";
          kauthamPlanner_ = p;
          si_ = si;
          //be careful these values should be set somehow!
          int level = 3;
          KthReal sigma = 0.1;

          _samplerRandom = new RandomSampler(kauthamPlanner_->wkSpace()->getDimension());
          _samplerHalton = new HaltonSampler(kauthamPlanner_->wkSpace()->getDimension());
          _samplerSDK = new SDKSampler(kauthamPlanner_->wkSpace()->getDimension(), level);
          _samplerGaussian = new GaussianSampler(kauthamPlanner_->wkSpace()->getDimension(), sigma, kauthamPlanner_->wkSpace());
          _samplerGaussianLike = new GaussianLikeSampler(kauthamPlanner_->wkSpace()->getDimension(), level, kauthamPlanner_->wkSpace());

          _samplerVector.push_back(_samplerRandom);
          _samplerVector.push_back(_samplerHalton);
          _samplerVector.push_back(_samplerSDK);
          _samplerVector.push_back(_samplerGaussian);
          _samplerVector.push_back(_samplerGaussianLike);
       }


      //!Gets a sample. The samplername parameter is defaulted to Random.
      //bool KauthamValidStateSampler::sample(ob::State *state, string samplername)
      bool KauthamValidStateSampler::sample(ob::State *state)
      {
          //gets a new sample using the sampler specified by the planner
          Sample* smp = NULL;
          int numSampler = ((omplPlanner*)kauthamPlanner_)->getSamplerUsed();
          if(numSampler>= _samplerVector.size()) numSampler = 0;//set default Random sampler if out of bounds value
          smp = _samplerVector[numSampler]->nextSample();


          /**/
          int d = kauthamPlanner_->wkSpace()->getDimension();
          vector<KthReal> coords(d);
          /*
          KthReal dummy=rng_.uniformReal(0,1.0);
          if(dummy < 0.2) {coords[0]=0.1; coords[1]=0.1;}
          else if(dummy < 0.4) {coords[0]=0.1; coords[1]=0.9;}
          else if(dummy < 0.6) {coords[0]=0.9; coords[1]=0.1;}
          else if(dummy < 0.999) {coords[0]=0.9; coords[1]=0.9;}
          if(dummy<1.0)
          {
              smp->setCoords(coords);
          }
          else
          {
              int kkk=0;
              kkk++;
          }
          */
          static int jj=0;
          if(jj==0) {coords[0]=0.1; coords[1]=0.1;jj++;}
          else if(jj==1) {coords[0]=0.1; coords[1]=0.9;jj++;}
          else if(jj==2) {coords[0]=0.9; coords[1]=0.1;jj++;}
          else if(jj==3) {coords[0]=0.9; coords[1]=0.9;jj=0;}
          else return false;
          smp->setCoords(coords);
          cout<<"smp coords= ("<<coords[0]<<", "<<coords[1]<<")"<<endl;

          /**/

          //computes the mapped configurations (i.e.se3+Rn values) by calling MoveRobotsto function.
          kauthamPlanner_->wkSpace()->moveRobotsTo(smp);

          //convert from sample to scoped state
          ob::ScopedState<ob::CompoundStateSpace> sstate(  ((omplPlanner*)kauthamPlanner_)->getSpace() );
          ((omplPlanner*)kauthamPlanner_)->smp2omplScopedState(smp, &sstate);


          /**/
          ob::StateSpacePtr ssRoboti = ((ob::StateSpacePtr) ((omplPlanner*)kauthamPlanner_)->getSpace()->as<ob::CompoundStateSpace>()->getSubspace(0));
          ob::StateSpacePtr ssRobotiRn =  ((ob::StateSpacePtr) ssRoboti->as<ob::CompoundStateSpace>()->getSubspace(0));
          ob::ScopedState<weigthedRealVectorStateSpace> pathscopedstateRn(ssRobotiRn);
          sstate >> pathscopedstateRn;
          cout<<"scopedState coords= ("<<pathscopedstateRn->values[0]<<", "<<pathscopedstateRn->values[1]<<")"<<endl;
          /**/






          //return the stae in the parameter state and a bool telling if the smp is in collision or not
          ((omplPlanner*)kauthamPlanner_)->getSpace()->copyState(state, sstate.get());

          if(  si_->satisfiesBounds(state)==false | kauthamPlanner_->wkSpace()->collisionCheck(smp) )
          //if( kauthamPlanner_->wkSpace()->collisionCheck(smp) )
              return false;
          return true;
      }

      //!Gets a sample near a given state, after several trials (retruns false if not found)
      bool KauthamValidStateSampler::sampleNear(ob::State *state, const ob::State *near, const double distance)
           {
               int trials = 0;
               int maxtrials=100;
               bool found = false;
               do{
                 //get a random sample, and compute the mapped configurations (i.e.se3+Rn values) by calling MoveRobotsto function.
                 Sample* smp = NULL;
                 int numSampler = 0; //Random sampler
                 smp = _samplerVector[numSampler]->nextSample();
                 kauthamPlanner_->wkSpace()->moveRobotsTo(smp);
                 //convert from sample to scoped state
                 ob::ScopedState<ob::CompoundStateSpace> sstate(  ((omplPlanner*)kauthamPlanner_)->getSpace() );
                 ((omplPlanner*)kauthamPlanner_)->smp2omplScopedState(smp, &sstate);
                 //return the stae in the parameter state and a bool telling if the smp is in collision or not
                 ((omplPlanner*)kauthamPlanner_)->getSpace()->copyState(state, sstate.get());
                 if( kauthamPlanner_->wkSpace()->collisionCheck(smp) | (((omplPlanner*)kauthamPlanner_)->getSpace()->distance(state,near)> distance) | !(si_->satisfiesBounds(state)))
                     found = false;
                 else
                     found=true;
                  trials ++;
               }while(found==false && trials <maxtrials);
               return found;
               //throw ompl::Exception("KauthamValidStateSampler::sampleNear", "not implemented");
               //return false;
           }



  /////////////////////////////////////////////////////////////////////////////////////////////////
  // AUXILIAR functions
  /////////////////////////////////////////////////////////////////////////////////////////////////

  /////////////////////////////////////////////////////////////////////////////////////////////////
  //! This function is used to allocate a state sampler
  ob::StateSamplerPtr allocStateSampler(const ob::StateSpace *mysspace, Planner *p)
  {
      return ob::StateSamplerPtr(new KauthamStateSampler(mysspace, p));
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  //! This function is used to allocate a valid state sampler
  ob::ValidStateSamplerPtr allocValidStateSampler(const ob::SpaceInformation *si, Planner *p)
  {
      return ob::ValidStateSamplerPtr(new KauthamValidStateSampler(si, p));
  }

//  /////////////////////////////////////////////////////////////////////////////////////////////////
//  //! This function converts a state to a smp and tests if it is in collision or not
//  bool isStateValid(const ob::SpaceInformation *si, const ob::State *state, Planner *p)
//  {
//      //verify bounds
//      if(si->satisfiesBounds(state)==false)
//          return false;
//      //create sample
//      int d = p->wkSpace()->getDimension();
//      Sample *smp = new Sample(d);
//      //copy the conf of the init smp. Needed to capture the home positions.
//      smp->setMappedConf(p->initSamp()->getMappedConf());
//      //load the RobConf of smp form the values of the ompl::state
//      ((omplPlanner*)p)->omplState2smp(state,smp);
//      //collision-check
//      if( p->wkSpace()->collisionCheck(smp) )
//          return false;
//      return true;
//  }




  /////////////////////////////////////////////////////////////////////////////////////////////////
  // omplPlanner functions
  /////////////////////////////////////////////////////////////////////////////////////////////////
  //! Constructor
  omplPlanner::omplPlanner(SPACETYPE stype, Sample *init, Sample *goal, SampleSet *samples, WorkSpace *ws):
             Planner(stype, init, goal, samples, ws)
    {
      _family = "ompl";
        //set intial values from parent class data
        _speedFactor = 1;
        _solved = false;
        _guiName = "ompl Planner";
        _idName = "ompl Planner";

        _samplerUsed = 0;

        //set own intial values
        _planningTime = 10;
        _simplify = 1;

        //add planner parameters
        addParameter("Max Planning Time", _planningTime);
        addParameter("Speed Factor", _speedFactor);
        addParameter("Simplify Solution", _simplify);

        //Construct the state space we are planning in. It is a compound state space composed of a compound state space for each robot
        //Each robot has a compound state space composed of a (oprional) SE3 state space and a (optional) Rn state space
        vector<ob::StateSpacePtr> spaceRn;
        vector<ob::StateSpacePtr> spaceSE3;
        vector<ob::StateSpacePtr> spaceRob;
        vector< double > weights;

        spaceRn.resize(_wkSpace->robotsCount());
        spaceSE3.resize(_wkSpace->robotsCount());
        spaceRob.resize(_wkSpace->robotsCount());
        weights.resize(_wkSpace->robotsCount());

        //loop for all robots
        for(int i=0; i<_wkSpace->robotsCount(); i++)
        {
            vector<ob::StateSpacePtr> compoundspaceRob;
            vector< double > weightsRob;
            std::stringstream sstm;

            //create state space SE3 for the mobile base, if necessary
            if(_wkSpace->getRobot(i)->isSE3Enabled())
            {
                //create the SE3 state space
                spaceSE3[i] = ((ob::StateSpacePtr) new ob::SE3StateSpace());
                sstm << "ssRobot" << i<<"_SE3";
                spaceSE3[i]->setName(sstm.str());

                //set the bounds. If the bounds are equal or its difference is below a given epsilon value (0.001) then
                //set the higher bound to the lower bound plus this eplsion
                ob::RealVectorBounds bounds(3);

                //x-direction
                double low = _wkSpace->getRobot(i)->getLimits(0)[0];
                double high = _wkSpace->getRobot(i)->getLimits(0)[1];
                filterBounds(low, high, 0.001);
                bounds.setLow(0, low);
                bounds.setHigh(0, high);

                //y-direction
                low = _wkSpace->getRobot(i)->getLimits(1)[0];
                high = _wkSpace->getRobot(i)->getLimits(1)[1];
                filterBounds(low, high, 0.001);
                bounds.setLow(1, low);
                bounds.setHigh(1, high);

                //z-direction
                low = _wkSpace->getRobot(i)->getLimits(2)[0];
                high = _wkSpace->getRobot(i)->getLimits(2)[1];
                filterBounds(low, high, 0.001);
                bounds.setLow(2, low);
                bounds.setHigh(2, high);

                spaceSE3[i]->as<ob::SE3StateSpace>()->setBounds(bounds);

                //create projections evaluator for this spaces
                ob::ProjectionEvaluatorPtr pei;
                pei = (ob::ProjectionEvaluatorPtr) new ob::RealVectorIdentityProjectionEvaluator(spaceSE3[i]->as<ob::SE3StateSpace>()->getSubspace(0));
                spaceSE3[i]->as<ob::SE3StateSpace>()->getSubspace(0)->registerDefaultProjection(pei);
                ob::ProjectionEvaluatorPtr pess;
                pess = (ob::ProjectionEvaluatorPtr) new ob::SubspaceProjectionEvaluator(&*spaceSE3[i],0);
                spaceSE3[i]->registerDefaultProjection(pess);
                //spaceSE3[i]->registerDefaultProjection(ob::ProjectionEvaluatorPtr (new ob::RealVectorIdentityProjectionEvaluator(spaceSE3[i])));


                //sets the weights between translation and rotation
                spaceSE3[i]->as<ob::SE3StateSpace>()->setSubspaceWeight(0,_wkSpace->getRobot(i)->getWeightSE3()[0]);//translational weight
                spaceSE3[i]->as<ob::SE3StateSpace>()->setSubspaceWeight(1,_wkSpace->getRobot(i)->getWeightSE3()[1]);//rotational weight

                //load to the compound state space of robot i
                compoundspaceRob.push_back(spaceSE3[i]);
                weightsRob.push_back(1);
            }

            //create the Rn state space for the kinematic chain, if necessary
            int nj = _wkSpace->getRobot(i)->getNumJoints();
            if(nj>0)
            {
                //create the Rn state space
                spaceRn[i] = ((ob::StateSpacePtr) new weigthedRealVectorStateSpace(nj));
                sstm << "ssRobot" << i<<"_Rn";
                spaceRn[i]->setName(sstm.str());

                //create projections evaluator for this spaces
                ob::ProjectionEvaluatorPtr pei;
                pei = ((ob::ProjectionEvaluatorPtr) new ob::RealVectorIdentityProjectionEvaluator(spaceRn[i]));
                spaceRn[i]->registerDefaultProjection(pei);

                // set the bounds and the weights
                vector<KthReal> jointweights;
                ob::RealVectorBounds bounds(nj);
                double low, high;
                for(int j=0; j<nj;j++)
                {
                    //the limits of joint j between link j and link (j+1) are stroed in the data structure of link (j+1)
                    low = *_wkSpace->getRobot(i)->getLink(j+1)->getLimits(true);
                    high = *_wkSpace->getRobot(i)->getLink(j+1)->getLimits(false);
                    filterBounds(low, high, 0.001);
                    bounds.setLow(j, low);
                    bounds.setHigh(j, high);
                    //the weights
                    jointweights.push_back(_wkSpace->getRobot(i)->getLink(j+1)->getWeight());
                }
                spaceRn[i]->as<weigthedRealVectorStateSpace>()->setBounds(bounds);
                spaceRn[i]->as<weigthedRealVectorStateSpace>()->setWeights(jointweights);

                //load to the compound state space of robot i
                compoundspaceRob.push_back(spaceRn[i]);
                weightsRob.push_back(1);
            }
            //the compound state space for robot i is (SE3xRn), and either SE3 or Rn may be missing
            spaceRob[i] = ((ob::StateSpacePtr) new ob::CompoundStateSpace(compoundspaceRob,weightsRob));
            weights[i] = 1;
            sstm.str("");
            sstm << "ssRobot" << i;
            spaceRob[i]->setName(sstm.str());

            ob::ProjectionEvaluatorPtr peri;
            peri = (ob::ProjectionEvaluatorPtr) new ob::SubspaceProjectionEvaluator(&*spaceRob[i],0);
            spaceRob[i]->registerDefaultProjection(peri);
        }
        //the state space for the set of robots. All the robots have the same weight.
        space = ((ob::StateSpacePtr) new ob::CompoundStateSpace(spaceRob,weights));

        ob::ProjectionEvaluatorPtr pesp;
        pesp = (ob::ProjectionEvaluatorPtr) new ob::SubspaceProjectionEvaluator(&*space,0);
        space->registerDefaultProjection(pesp);


        //The classes derived from this omplplanner class will create a planner,
        //the simplesetup and call the setStateValididyChecker function
    }

	//! void destructor
    omplPlanner::~omplPlanner(){
			
	}
	
    //! This function setParameters sets the parameters of the planner
    bool omplPlanner::setParameters(){
      try{
        HASH_S_K::iterator it = _parameters.find("Speed Factor");
        if(it != _parameters.end())
          _speedFactor = it->second;
        else
          return false;

        it = _parameters.find("Max Planning Time");
        if(it != _parameters.end())
            _planningTime = it->second;
        else
          return false;

        it = _parameters.find("Simplify Solution");
        if(it != _parameters.end())
        {
            if(it->second==0) _simplify=0;
            else _simplify=1;
        }
        else
          return false;

      }catch(...){
        return false;
      }
      return true;
    }

    //! This function is used to verify that the low bound is below the high bound
    void omplPlanner::filterBounds(double &l, double &h, double epsilon)
    {
        if((h - l) < epsilon) h = l + epsilon;
    }

    //! This function creates the separator for the ivscene to show the configuration space.
    SoSeparator *omplPlanner::getIvCspaceScene()
    {
        _sceneCspace = new SoSeparator();
        return Planner::getIvCspaceScene();
    }


    //! This routine allows to draw the 2D projection of a roadmap or tree
   void omplPlanner::drawCspace()
    {
            //first delete whatever is already drawn
            while (_sceneCspace->getNumChildren() > 0)
            {
                _sceneCspace->removeChild(0);
            }

            //to draw points
            SoSeparator *psep = new SoSeparator();
            SoCoordinate3 *points  = new SoCoordinate3();
            SoPointSet *pset  = new SoPointSet();

            //get the first subspace
            ob::StateSpacePtr ssRoboti = ((ob::StateSpacePtr) space->as<ob::CompoundStateSpace>()->getSubspace(0));
            ob::StateSpacePtr ssRobotifirst =  ((ob::StateSpacePtr) ssRoboti->as<ob::CompoundStateSpace>()->getSubspace(0));

            //space bounds
            int k;
            KthReal xmin;
            KthReal xmax;
            KthReal ymin;
            KthReal ymax;
            KthReal zmin;
            KthReal zmax;

            if(_wkSpace->getRobot(0)->isSE3Enabled())
            {

                xmin=ssRobotifirst->as<ob::SE3StateSpace>()->getBounds().low[0];
                xmax=ssRobotifirst->as<ob::SE3StateSpace>()->getBounds().high[0];
                ymin=ssRobotifirst->as<ob::SE3StateSpace>()->getBounds().low[1];
                ymax=ssRobotifirst->as<ob::SE3StateSpace>()->getBounds().high[1];
                zmin=ssRobotifirst->as<ob::SE3StateSpace>()->getBounds().low[2];
                zmax=ssRobotifirst->as<ob::SE3StateSpace>()->getBounds().high[2];
                k = ssRobotifirst->as<ob::SE3StateSpace>()->getDimension();
            }
            else
            {
                k = ssRobotifirst->as<ob::RealVectorStateSpace>()->getDimension();
                if(k<=2)
                {
                    xmin=ssRobotifirst->as<ob::RealVectorStateSpace>()->getBounds().low[0];
                    xmax=ssRobotifirst->as<ob::RealVectorStateSpace>()->getBounds().high[0];
                    ymin=ssRobotifirst->as<ob::RealVectorStateSpace>()->getBounds().low[1];
                    ymax=ssRobotifirst->as<ob::RealVectorStateSpace>()->getBounds().high[1];
                }
                else
                {
                    xmin=ssRobotifirst->as<ob::RealVectorStateSpace>()->getBounds().low[0];
                    xmax=ssRobotifirst->as<ob::RealVectorStateSpace>()->getBounds().high[0];
                    ymin=ssRobotifirst->as<ob::RealVectorStateSpace>()->getBounds().low[1];
                    ymax=ssRobotifirst->as<ob::RealVectorStateSpace>()->getBounds().high[1];
                    zmin=ssRobotifirst->as<ob::RealVectorStateSpace>()->getBounds().low[2];
                    zmax=ssRobotifirst->as<ob::RealVectorStateSpace>()->getBounds().high[2];
                }
            }


            KthReal x,y,z;
            //load the planner data to be drawn
            ob::PlannerDataPtr pdata;
            pdata = ((ob::PlannerDataPtr) new ob::PlannerData(ss->getSpaceInformation()));
            ss->getPlanner()->getPlannerData(*pdata);

            //draw path:
            if(_solved)
            {
                //separator for the solution path
                SoSeparator *pathsep = new SoSeparator();
                //get the states of the solution path
                std::vector< ob::State * > & pathstates = ss->getSolutionPath().getStates();

                //loop for al the states of the solution path
                for(int i=0; i<ss->getSolutionPath().getStateCount()-1; i++)
                {
                    //initial edgepoint
                    SoCoordinate3 *edgepoints  = new SoCoordinate3();
                    if(_wkSpace->getRobot(0)->isSE3Enabled())
                    {
                        ob::EuclideanProjection projection(k);
                        space->getDefaultProjection()->project(pathstates[i], projection);
                        x=projection[0];
                        y=projection[1];
                        z=projection[2];
                        edgepoints->point.set1Value(0,x,y,z);

                    //final edgepoint
                        space->getDefaultProjection()->project(pathstates[i+1], projection);
                        x=projection[0];
                        y=projection[1];
                        z=projection[2];
                        edgepoints->point.set1Value(1,x,y,z);
                    }
                    else
                    {
                        k = ssRobotifirst->as<ob::RealVectorStateSpace>()->getDimension();
                        if(k<=2)
                        {
                            ob::EuclideanProjection projection(k);
                            space->getDefaultProjection()->project(pathstates[i], projection);
                            x=projection[0];
                            y=projection[1];
                            z=0.0;
                            edgepoints->point.set1Value(0,x,y,z);
                            space->getDefaultProjection()->project(pathstates[i+1],projection);
                            x=projection[0];
                            y=projection[1];
                            edgepoints->point.set1Value(1,x,y,z);
                        }
                        else
                        {
                            ob::EuclideanProjection projection(k);
                            space->getDefaultProjection()->project(pathstates[i], projection);
                            x=projection[0];
                            y=projection[1];
                            z=projection[2];
                            edgepoints->point.set1Value(0,x,y,z);
                            space->getDefaultProjection()->project(pathstates[i+1],projection);
                            x=projection[0];
                            y=projection[1];
                            z=projection[2];
                            edgepoints->point.set1Value(1,x,y,z);
                        }
                    }

                    //edge of the path
                    pathsep->addChild(edgepoints);
                    SoLineSet *ls = new SoLineSet;
                    ls->numVertices.set1Value(0,2);//two values
                    SoDrawStyle *lstyle = new SoDrawStyle;
                    lstyle->lineWidth=2;
                    SoMaterial *path_color = new SoMaterial;
                    path_color->diffuseColor.setValue(0.8,0.2,0.2);
                    pathsep->addChild(path_color);
                    pathsep->addChild(lstyle);
                    pathsep->addChild(ls);
                }
                _sceneCspace->addChild(pathsep);
            }




            //loop for all vertices of the roadmap or tree and create the coin3D points
            for(int i=0;i<pdata->numVertices();i++)
            {
                if(_wkSpace->getRobot(0)->isSE3Enabled())
                {
                    ob::EuclideanProjection projection(k);
                //&(projection) = new ob::EuclideanProjection;
                //try
                //{
                    space->getDefaultProjection()->project(pdata->getVertex(i).getState(), projection);
                // }
                //catch(ompl::Exception e){
                  //  e.what();
                //}
                    x = projection[0];
                    y = projection[1];
                    z = projection[2];

                    points->point.set1Value(i,x,y,z);

                    /**/
                    KthReal xxx=pdata->getVertex(i).getState()->as<ob::SE3StateSpace::StateType>()->getX();
                    KthReal yyy=pdata->getVertex(i).getState()->as<ob::SE3StateSpace::StateType>()->getY();
                    cout<<"x="<<x<<" y="<<y<<endl;
                    cout<<"xxx="<<x<<" yyy="<<y<<endl;
                    /**/
                }
                else
                {
                    k = ssRobotifirst->as<ob::RealVectorStateSpace>()->getDimension();
                    if(k<=2)
                    {
                        ob::EuclideanProjection projection(k);
                        space->getDefaultProjection()->project(pdata->getVertex(i).getState(), projection);
                        x = projection[0];
                        y = projection[1];
                        points->point.set1Value(i,x,y,0);
                    }
                    else
                    {
                        ob::EuclideanProjection projection(k);
                        space->getDefaultProjection()->project(pdata->getVertex(i).getState(), projection);
                        x = projection[0];
                        y = projection[1];
                        z = projection[2];
                        points->point.set1Value(i,x,y,z);


                        /**/
                        KthReal xxx=pdata->getVertex(i).getState()->as<weigthedRealVectorStateSpace::StateType>()->values[0];
                        KthReal yyy=pdata->getVertex(i).getState()->as<weigthedRealVectorStateSpace::StateType>()->values[1];
                        cout<<"x="<<x<<" y="<<y<<endl;
                        cout<<"xxx="<<x<<" yyy="<<y<<endl;
                        /**/



                    }
                }

            }
            SoDrawStyle *pstyle = new SoDrawStyle;
            pstyle->pointSize = 3;
            SoMaterial *color = new SoMaterial;
            color->diffuseColor.setValue(0.2,0.8,0.2);

            //draw the points
            psep->addChild(color);
            psep->addChild(points);
            psep->addChild(pstyle);
            psep->addChild(pset);
            _sceneCspace->addChild(psep);

            //draw edges:
            SoSeparator *lsep = new SoSeparator();
            int numOutgoingEdges;
            std::vector< unsigned int > outgoingVertices;

            //loop for all nodes
            for(int i=0;i<pdata->numVertices();i++)
            {
                 numOutgoingEdges = pdata->getEdges (i, outgoingVertices);

                 //for each node loop for all the outgoing edges
                 for ( int j=0; j<numOutgoingEdges; j++ )
                 {

                    SoCoordinate3 *edgepoints  = new SoCoordinate3();

                    //initial edgepoint
                    float x1,y1,x2,y2,z1,z2;
                    if(_wkSpace->getRobot(0)->isSE3Enabled())
                    {
                        ob::EuclideanProjection projection(k);
                        space->getDefaultProjection()->project(pdata->getVertex(i).getState(), projection);
                        x1=projection[0];
                        y1=projection[1];
                        z1=projection[2];
                        edgepoints->point.set1Value(0,x1,y1,z1);

                    //final edgepoint
                        space->getDefaultProjection()->project(pdata->getVertex(outgoingVertices.at(j)).getState(), projection);
                        x2=projection[0];
                        y2=projection[1];
                        z2=projection[2];
                        edgepoints->point.set1Value(1,x2,y2,z2);
                    }
                    else
                    {
                        k = ssRobotifirst->as<ob::RealVectorStateSpace>()->getDimension();
                        if(k<=2)
                        {
                            ob::EuclideanProjection projection(k);
                            space->getDefaultProjection()->project(pdata->getVertex(i).getState(), projection);
                            x1=projection[0];
                            y1=projection[1];
                            z=0.0;
                            edgepoints->point.set1Value(0,x1,y1,z);
                            space->getDefaultProjection()->project(pdata->getVertex(outgoingVertices.at(j)).getState(),projection);
                            x2=projection[0];
                            y2=projection[1];
                            edgepoints->point.set1Value(1,x2,y2,z);
                        }
                        else
                        {
                            ob::EuclideanProjection projection(k);
                            space->getDefaultProjection()->project(pdata->getVertex(i).getState(), projection);
                            x1=projection[0];
                            y1=projection[1];
                            z1=projection[2];
                            edgepoints->point.set1Value(0,x1,y1,z1);
                            space->getDefaultProjection()->project(pdata->getVertex(outgoingVertices.at(j)).getState(),projection);
                            x2=projection[0];
                            y2=projection[1];
                            z2=projection[2];
                            edgepoints->point.set1Value(1,x2,y2,z2);
                        }
                    }
                    //the edge
                    lsep->addChild(edgepoints);
                    SoLineSet *ls = new SoLineSet;
                    ls->numVertices.set1Value(0,2);//two values
                    lsep->addChild(ls);
                 }
            }
           _sceneCspace->addChild(lsep);



            SoSeparator *floorsep = new SoSeparator();
            SoCube *cs = new SoCube();
            SoTransform *cub_transf = new SoTransform;
            SbVec3f centre;
            SoMaterial *cub_color = new SoMaterial;
            //draw floor
            if(_wkSpace->getRobot(0)->isSE3Enabled())
            {
                cs->width = xmax-xmin;
                cs->depth = (zmax-zmin);
                cs->height = ymax-ymin;

                centre.setValue(xmin+(xmax-xmin)/2,ymin+(ymax-ymin)/2,zmin+(zmax-zmin)/2);
                cub_transf->translation.setValue(centre);
                cub_transf->recenter(centre);

                //SoMaterial *cub_color = new SoMaterial;
                cub_color->diffuseColor.setValue(0.2,0.2,0.2);
                cub_color->transparency.setValue(0.5);

                floorsep->addChild(cub_color);
                floorsep->addChild(cub_transf);
                floorsep->addChild(cs);
                _sceneCspace->addChild(floorsep);
            }
            else
            {
                k = ssRobotifirst->as<ob::RealVectorStateSpace>()->getDimension();
                if(k<=2)
                {
                    cs->width = xmax-xmin;
                    cs->depth = (xmax-xmin)/50.0;
                    cs->height = ymax-ymin;
                    centre.setValue(xmin+(xmax-xmin)/2,ymin+(ymax-ymin)/2,-cs->depth.getValue());
                    cub_transf->translation.setValue(centre);
                    cub_transf->recenter(centre);
                    cub_color->diffuseColor.setValue(0.2,0.2,0.2);
                    //cub_color->transparency.setValue(0.98);
                    floorsep->addChild(cub_color);
                    floorsep->addChild(cub_transf);
                    floorsep->addChild(cs);
                    _sceneCspace->addChild(floorsep);
                }
                else
                {
                    cs->width = xmax-xmin;
                    cs->depth = (zmax-zmin);
                    cs->height = ymax-ymin;
                    centre.setValue(xmin+(xmax-xmin)/2,ymin+(ymax-ymin)/2,zmin+(zmax-zmin)/2);
                    cub_transf->translation.setValue(centre);
                    cub_transf->recenter(centre);
                    cub_color->diffuseColor.setValue(0.2,0.2,0.2);
                    cub_color->transparency.setValue(0.08);//(0.98);
                    floorsep->addChild(cub_color);
                    floorsep->addChild(cub_transf);
                    floorsep->addChild(cs);
                    _sceneCspace->addChild(floorsep);
                }
             }
    }

    //! This function converts a Kautham sample to an ompl scoped state.
    void omplPlanner::smp2omplScopedState(Sample* smp, ob::ScopedState<ob::CompoundStateSpace> *sstate)
    {
        //Extract the mapped configuration of the sample. It is a vector with as many components as robots.
        //each component has the RobConf of the robot (the SE3 and the Rn configurations)
        if(smp->getMappedConf().size()==0)
        {
            _wkSpace->moveRobotsTo(smp); // to set the mapped configuration
        }
        std::vector<RobConf>& smpRobotsConf = smp->getMappedConf();


        //loop for all the robots
        for(int i=0; i<_wkSpace->robotsCount(); i++)
        {
            int k=0; //counter of subspaces contained in subspace of robot i

            //get the subspace of robot i
            ob::StateSpacePtr ssRoboti = ((ob::StateSpacePtr) space->as<ob::CompoundStateSpace>()->getSubspace(i));
            string ssRobotiname = ssRoboti->getName();

            //if it has se3 part
            if(_wkSpace->getRobot(i)->isSE3Enabled())
            {
                //get the kautham SE3 configuration
                SE3Conf c = smpRobotsConf.at(i).getSE3();
                vector<KthReal>& pp = c.getPos();
                vector<KthReal>& aa = c.getAxisAngle();

                //set the ompl SE3 configuration
                ob::StateSpacePtr ssRobotiSE3 =  ((ob::StateSpacePtr) ssRoboti->as<ob::CompoundStateSpace>()->getSubspace(k));
                string ssRobotiSE3name = ssRobotiSE3->getName();

                ob::ScopedState<ob::SE3StateSpace> cstart(ssRobotiSE3);
                cstart->setX(pp[0]);
                cstart->setY(pp[1]);
                cstart->setZ(pp[2]);
                cstart->rotation().setAxisAngle(aa[0],aa[1],aa[2],aa[3]);

                //load the global scoped state with the info of the se3 data of robot i
                (*sstate)<<cstart;
                k++;
            }

            //has Rn part
            if(_wkSpace->getRobot(i)->getNumJoints()>0)
            {
                //get the kautham Rn configuration
                RnConf r = smpRobotsConf.at(i).getRn();

                //set the ompl Rn configuration
                ob::StateSpacePtr ssRobotiRn =  ((ob::StateSpacePtr) ssRoboti->as<ob::CompoundStateSpace>()->getSubspace(k));
                ob::ScopedState<weigthedRealVectorStateSpace> rstart(ssRobotiRn);

                for(int j=0; j<_wkSpace->getRobot(i)->getNumJoints();j++)
                    rstart->values[j] = r.getCoordinate(j);

                cout<<"sstate[0]="<<rstart->values[0]<<"sstate[1]="<<rstart->values[1]<<endl;


                //load the global scoped state with the info of the Rn data of robot i
                (*sstate) << rstart;
                k++;//dummy
            }
        }
    }

    //! This member function converts an ompl State to a Kautham sample
    void omplPlanner::omplState2smp(const ob::State *state, Sample* smp)
    {
        ob::ScopedState<ob::CompoundStateSpace> sstate(space);
        sstate = *state;
        omplScopedState2smp( sstate, smp);
    }

    //! This member function converts an ompl ScopedState to a Kautham sample
    void omplPlanner::omplScopedState2smp(ob::ScopedState<ob::CompoundStateSpace> sstate, Sample* smp)
    {
        int k=0;
        vector<RobConf> rc;

        //loop for all the robots
        for(int i=0; i<_wkSpace->robotsCount(); i++)
        {
            //RobConf to store the robots configurations read form the ompl state
            RobConf *rcj = new RobConf;

            //Get the subspace corresponding to robot i
            ob::StateSpacePtr ssRoboti = ((ob::StateSpacePtr) space->as<ob::CompoundStateSpace>()->getSubspace(i));

            //Get the SE3 subspace of robot i, if it exisits, and extract the SE3 configuration
            int k=0; //counter of subspaces of robot i
            if(_wkSpace->getRobot(i)->isSE3Enabled())
            {
                //Get the SE3 subspace of robot i
                 ob::StateSpacePtr ssRobotiSE3 =  ((ob::StateSpacePtr) ssRoboti->as<ob::CompoundStateSpace>()->getSubspace(k));

                 //create a SE3 scoped state and load it with the data extracted from the global scoped state
                 ob::ScopedState<ob::SE3StateSpace> pathscopedstatese3(ssRobotiSE3);
                 sstate >> pathscopedstatese3;

                 //convert to a vector of 7 components
                 vector<KthReal> se3coords;
                 se3coords.resize(7);
                 se3coords[0] = pathscopedstatese3->getX();
                 se3coords[1] = pathscopedstatese3->getY();
                 se3coords[2] = pathscopedstatese3->getZ();
                 se3coords[3] = pathscopedstatese3->rotation().x;
                 se3coords[4] = pathscopedstatese3->rotation().y;
                 se3coords[5] = pathscopedstatese3->rotation().z;
                 se3coords[6] = pathscopedstatese3->rotation().w;
                 //create the sample
                 SE3Conf se3;
                 se3.setCoordinates(se3coords);
                 rcj->setSE3(se3);
                 k++;
             }
             //If the robot does not have movile SE3 dofs then the SE3 configuration of the sample is maintained
             else
             {
                 if(smp->getMappedConf().size()==0)
                     throw ompl::Exception("omplPlanner::omplScopedState2smp", "parameter smp must be a sample with the MappedConf");
                 else
                     rcj->setSE3(smp->getMappedConf()[i].getSE3());
             }


            //Get the Rn subspace of robot i, if it exisits, and extract the Rn configuration
             if(_wkSpace->getRobot(i)->getNumJoints()>0)
             {
                 //Get the Rn subspace of robot i
                 ob::StateSpacePtr ssRobotiRn =  ((ob::StateSpacePtr) ssRoboti->as<ob::CompoundStateSpace>()->getSubspace(k));

                 //create a Rn scoped state and load it with the data extracted from the global scoped state
                 ob::ScopedState<weigthedRealVectorStateSpace> pathscopedstateRn(ssRobotiRn);
                 sstate >> pathscopedstateRn;

                 //convert to a vector of n components
                 vector<KthReal> coords;
                 for(int j=0;j<_wkSpace->getRobot(i)->getNumJoints();j++) coords.push_back(pathscopedstateRn->values[j]);
                 rcj->setRn(coords);
                 k++;//dummy
             }
             //If the robot does not have movile Rn dofs then the Rn configuration of the sample is maintained
             else
             {
                 if(smp->getMappedConf().size()==0)
                     throw ompl::Exception("omplPlanner::omplScopedState2smp", "parameter smp must be a sample with the MappedConf");
                 else
                     rcj->setRn(smp->getMappedConf()[i].getRn());
             }
             //load the RobConf with the data of robot i
             rc.push_back(*rcj);
        }
        //create the sample with the RobConf
        //the coords (controls) of the sample are kept void
        smp->setMappedConf(rc);
    }


	//! function to find a solution path
    bool omplPlanner::trySolve()
    {
        //Start state: convert from smp to scoped state
        ob::ScopedState<ob::CompoundStateSpace> startompl(space);
        smp2omplScopedState(_init, &startompl);
        cout<<"startompl:"<<endl;
        startompl.print();

        //Goal state: convert from smp to scoped state
         ob::ScopedState<ob::CompoundStateSpace> goalompl(space);
         smp2omplScopedState(_goal, &goalompl);
         cout<<"goalompl:"<<endl;
         goalompl.print();

         // set the start and goal states
         ss->setStartAndGoalStates(startompl, goalompl);

         //remove previous solutions, if any
         ss->clear();
         ss->getPlanner()->clear();

         // attempt to solve the problem within _planningTime seconds of planning time
         ss->setup();
         ob::PlannerStatus solved = ss->solve(_planningTime);

         //ss->print();

         //retrieve all the states. Load the SampleSet _samples
         Sample *smp;
         ob::PlannerData data(ss->getSpaceInformation());
         ss->getPlannerData(data);
         /*
         for(int i=0; i<data.numVertices();i++)
         {
                smp=new Sample(_wkSpace->getDimension());
                smp->setMappedConf(_init->getMappedConf());//copy the conf of the start smp
                omplState2smp(data.getVertex(i).getState(), smp);
                _samples->add(smp);
         }
         */

         if (solved)
         {
                std::cout << "Found solution:" << std::endl;
                // print the path to screen
                if(_simplify!=0) ss->simplifySolution();
                ss->getSolutionPath().print(std::cout);
                std::vector< ob::State * > & pathstates = ss->getSolutionPath().getStates();

                Sample *smp;

                _path.clear();
                clearSimulationPath();


               //load the kautham _path variable from the ompl solution
                for(int j=0;j<ss->getSolutionPath().getStateCount();j++){
                   //create a smp and load the RobConf of the init configuration (to have the same if the state does not changi it)
                    smp=new Sample(_wkSpace->getDimension());
                    smp->setMappedConf(_init->getMappedConf());
                    //convert form state to smp
                    omplState2smp(ss->getSolutionPath().getState(j)->as<ob::CompoundStateSpace::StateType>(), smp);

                    _path.push_back(smp);
                    _samples->add(smp);
                }
                _solved = true;
                drawCspace();
                return _solved;
            }
            //solution not found
            else{
                std::cout << "No solution found" << std::endl;
                _solved = false;
                drawCspace();
                return _solved;
            }
		}
    }
  /** @}   end of Doxygen module "libPlanner */
}


#endif // KAUTHAM_USE_OMPL


