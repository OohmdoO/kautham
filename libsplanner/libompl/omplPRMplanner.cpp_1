/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 
 

#if defined(KAUTHAM_USE_OMPL)
#include <libproblem/workspace.h>
#include <libsampling/sampling.h>

#include <ompl/geometric/planners/prm/ConnectionStrategy.h>
#include <ompl/base/goals/GoalSampleableRegion.h>
#include <ompl/datastructures/PDF.h>
#include <ompl/tools/config/SelfConfig.h>
#include <boost/bind/mem_fn.hpp>
#include <boost/lambda/bind.hpp>
#include <boost/graph/astar_search.hpp>
#include <boost/graph/incremental_components.hpp>
#include <boost/property_map/vector_property_map.hpp>
#include <boost/foreach.hpp>
#include <boost/thread.hpp>

#define foreach BOOST_FOREACH
#define foreach_reverse BOOST_REVERSE_FOREACH

#include "omplPRMplanner.h"




using namespace libSampling;

namespace libPlanner {
  namespace omplplanner{

      namespace magic
      {

          /** \brief Maximum number of sampling attempts to find a valid state,
              without checking whether the allowed time elapsed. This value
              should not really be changed. */
          static const unsigned int FIND_VALID_STATE_ATTEMPTS_WITHOUT_TIME_CHECK = 2;

          /** \brief The number of steps to take for a random bounce
              motion generated as part of the expansion step of PRM. */
          static const unsigned int MAX_RANDOM_BOUNCE_STEPS   = 5;

          /** \brief The number of nearest neighbors to consider by
              default in the construction of the PRM roadmap */
          static const unsigned int DEFAULT_NEAREST_NEIGHBORS = 10;

          /** \brief The time in seconds for a single roadmap building operation (dt)*/
          static const double ROADMAP_BUILD_TIME = 0.2;
      }




  //class myPRM;

  struct vertex_state_t {
                      typedef boost::vertex_property_tag kind;
                  };

                  struct vertex_total_connection_attempts_t {
                      typedef boost::vertex_property_tag kind;
                  };

                  struct vertex_successful_connection_attempts_t {
                      typedef boost::vertex_property_tag kind;
                  };

  typedef boost::adjacency_list <
                     boost::vecS, boost::vecS, boost::undirectedS,
                     boost::property < vertex_state_t, ob::State*,
                     boost::property < vertex_total_connection_attempts_t, unsigned int,
                     boost::property < vertex_successful_connection_attempts_t, unsigned int,
                     boost::property < boost::vertex_predecessor_t, unsigned long int,
                     boost::property < boost::vertex_rank_t, unsigned long int > > > > >,
                     boost::property < boost::edge_weight_t, double,
                     boost::property < boost::edge_index_t, unsigned int> >
                 > Graph;

 typedef boost::graph_traits<Graph>::vertex_descriptor Vertex;


/*

  class myPRM:public og::PRM
  {
    public:
      myPRM(const ob::SpaceInformationPtr &si, bool starStrategy=false) :  og::PRM(si,starStrategy)
      {
      }
      ~myPRM(void)
      {
          freeMemory();
      }

      //reimplemented
      ob::PlannerStatus solve(const ob::PlannerTerminationCondition &ptc)
      {
          checkValidity();
          ob::GoalSampleableRegion *goal = dynamic_cast<ob::GoalSampleableRegion*>(pdef_->getGoal().get());

          if (!goal)
          {
              OMPL_ERROR("Goal undefined or unknown type of goal");
              return ob::PlannerStatus::UNRECOGNIZED_GOAL_TYPE;
          }

          // Add the valid start states as milestones
          while (const ob::State *st = pis_.nextStart())
              startM_.push_back(addMilestone(si_->cloneState(st)));

          if (startM_.size() == 0)
          {
              OMPL_ERROR("There are no valid initial states!");
              return ob::PlannerStatus::INVALID_START;
          }

          if (!goal->couldSample())
          {
              OMPL_ERROR("Insufficient states in sampleable goal region");
              return ob::PlannerStatus::INVALID_GOAL;
          }

          // Ensure there is at least one valid goal state
          if (goal->maxSampleCount() > goalM_.size() || goalM_.empty())
          {
              const ob::State *st = goalM_.empty() ? pis_.nextGoal(ptc) : pis_.nextGoal();
              if (st)
                  goalM_.push_back(addMilestone(si_->cloneState(st)));

              if (goalM_.empty())
              {
                  OMPL_ERROR("Unable to find any valid goal states");
                  return ob::PlannerStatus::INVALID_GOAL;
              }
          }

          if (!sampler_)
              sampler_ = si_->allocValidStateSampler();
          if (!simpleSampler_)
              simpleSampler_ = si_->allocStateSampler();

          unsigned int nrStartStates = boost::num_vertices(g_);
          OMPL_INFORM("Starting with %u states", nrStartStates);

          std::vector<ob::State*> xstates(magic::MAX_RANDOM_BOUNCE_STEPS);
          si_->allocStates(xstates);
          bool grow = true;

          // Reset addedSolution_ member and create solution checking thread
          addedSolution_ = false;
          ob::PathPtr sol;
          sol.reset();
          boost::thread slnThread (boost::bind(&og::PRM::checkForSolution, this, ptc, boost::ref(sol)));

          // construct new planner termination condition that fires when the given ptc is true, or a solution is found
          ob::PlannerOrTerminationCondition ptcOrSolutionFound (ptc, ob::PlannerTerminationCondition(boost::bind(&og::PRM::addedNewSolution, this)));

          while (ptcOrSolutionFound() == false)
          {
              // maintain a 2:1 ratio for growing/expansion of roadmap
              // call growRoadmap() twice as long for every call of expandRoadmap()
              if (grow)
                  growRoadmap(ob::PlannerOrTerminationCondition(ptcOrSolutionFound, ob::timedPlannerTerminationCondition(2.0*magic::ROADMAP_BUILD_TIME)), xstates[0]);
              else
                  myexpandRoadmap(ob::PlannerOrTerminationCondition(ptcOrSolutionFound, ob::timedPlannerTerminationCondition(magic::ROADMAP_BUILD_TIME)), xstates);
              grow = !grow;
          }

          // Ensure slnThread is ceased before exiting solve
          slnThread.join();

          OMPL_INFORM("Created %u states", boost::num_vertices(g_) - nrStartStates);

          if (sol)
          {
              if (addedNewSolution())
                  pdef_->addSolutionPath (sol);
              else
                  // the solution is exact, but not as short as we'd like it to be
                  pdef_->addSolutionPath (sol, true, 0.0);
          }

          si_->freeStates(xstates);

          // Return true if any solution was found.
          return sol ? (addedNewSolution() ? ob::PlannerStatus::EXACT_SOLUTION : ob::PlannerStatus::APPROXIMATE_SOLUTION) : ob::PlannerStatus::TIMEOUT;
      }

      //reimplemented
      void expandRoadmap(const ob::PlannerTerminationCondition &ptc)
      {
          if (!simpleSampler_)
              simpleSampler_ = si_->allocStateSampler();

          std::vector<ob::State*> states(magic::MAX_RANDOM_BOUNCE_STEPS);
          si_->allocStates(states);
          myexpandRoadmap(ptc, states);
          si_->freeStates(states);
      }

      //idem as PRM::expandRoadmap but with distance filter
      void myexpandRoadmap(const ob::PlannerTerminationCondition &ptc,
                                               std::vector<ob::State*> &workStates)
      {
          // construct a probability distribution over the vertices in the roadmap
          // as indicated in
          //  "Probabilistic Roadmaps for Path Planning in High-Dimensional Configuration Spaces"
          //        Lydia E. Kavraki, Petr Svestka, Jean-Claude Latombe, and Mark H. Overmars

          ompl::PDF<Vertex> pdf;
          foreach (Vertex v, boost::vertices(g_))
          {
              const unsigned int t = totalConnectionAttemptsProperty_[v];
              pdf.add(v, (double)(t - successfulConnectionAttemptsProperty_[v]) / (double)t);
          }

          if (pdf.empty())
              return;

          while (ptc == false)
          {
              Vertex v = pdf.sample(rng_.uniform01());
              unsigned int s = si_->randomBounceMotion(simpleSampler_, stateProperty_[v], workStates.size(), workStates, false);
              if (s > 0)
              {
                  s--;
                  Vertex last = addMilestone(si_->cloneState(workStates[s]));

                  graphMutex_.lock();
                  for (unsigned int i = 0 ; i < s ; ++i)
                  {
                      // add the vertex along the bouncing motion
                      Vertex m = boost::add_vertex(g_);
                      stateProperty_[m] = si_->cloneState(workStates[i]);
                      totalConnectionAttemptsProperty_[m] = 1;
                      successfulConnectionAttemptsProperty_[m] = 0;
                      disjointSets_.make_set(m);

                      // add the edge to the parent vertex
                      if(connectionFilter_(v, m))
                      {
                         const double weight = distanceFunction(v, m);
                         cout<<"d= "<<weight<<endl;
                         const unsigned int id = maxEdgeID_++;
                         const Graph::edge_property_type properties(weight, id);
                         boost::add_edge(v, m, properties, g_);
                         uniteComponents(v, m);
                      }

                      // add the vertex to the nearest neighbors data structure
                      nn_->add(m);
                      v = m;
                  }

                  // if there are intermediary states or the milestone has not been connected to the initially sampled vertex,
                  // we add an edge
                  if (s > 0 || !boost::same_component(v, last, disjointSets_))
                  {
                      // add the edge to the parent vertex
                      const double weight = distanceFunction(v, last);
                      const unsigned int id = maxEdgeID_++;
                      const Graph::edge_property_type properties(weight, id);
                      boost::add_edge(v, last, properties, g_);
                      uniteComponents(v, last);
                  }
                  graphMutex_.unlock();
              }
          }
      }

  };
*/

  bool connectionDistanceFilter(const Vertex& v1, const Vertex& v2, double d, ob::PlannerPtr pl)
  {
      //if(pl->as<myPRM>()->distanceFunction(v1,v2) < d) return true;
      if(pl->as<og::PRM>()->distanceFunction(v1,v2) < d) return true;
      else return false;
  }




	//! Constructor
    omplPRMPlanner::omplPRMPlanner(SPACETYPE stype, Sample *init, Sample *goal, SampleSet *samples, Sampler *sampler, WorkSpace *ws, LocalPlanner *lcPlan, KthReal ssize):
              omplPlanner(stype, init, goal, samples, sampler, ws, lcPlan, ssize)
	{
        _guiName = "ompl PRM Planner";
        _idName = "omplPRM";


        space->setStateSamplerAllocator(boost::bind(&omplplanner::allocStateSampler, _1, (Planner*)this));

        ss = ((og::SimpleSetupPtr) new og::SimpleSetup(space));
        ss->setStateValidityChecker(boost::bind(&omplplanner::isStateValid, _1, (Planner*)this));

        ob::SpaceInformationPtr si=ss->getSpaceInformation();
        si->setValidStateSamplerAllocator(boost::bind(&omplplanner::allocValidStateSampler, _1, (Planner*)this));


        //ob::PlannerPtr planner(new myPRM(si));
        ob::PlannerPtr planner(new og::PRM(si));


       //typedef boost::function<bool(const State *)>   StateValidityCheckerFn
       // typedef boost::function<bool(const Vertex&, const Vertex&)> ompl::geometric::PRM::ConnectionFilter

        double _distanceThreshold = 5.0;
        addParameter("DistanceThreshold", _distanceThreshold);
        //planner->as<myPRM>()->setConnectionFilter(boost::bind(&omplplanner::connectionDistanceFilter, _1,_2, _distanceThreshold, planner));
        planner->as<og::PRM>()->setConnectionFilter(boost::bind(&omplplanner::connectionDistanceFilter, _1,_2, _distanceThreshold, planner));

        ss->setPlanner(planner);

        _MaxNearestNeighbors=10;
        addParameter("MaxNearestNeighbors", _MaxNearestNeighbors);

        //ss->getPlanner()->as<myPRM>()->setMaxNearestNeighbors(_MaxNearestNeighbors);
        ss->getPlanner()->as<og::PRM>()->setMaxNearestNeighbors(_MaxNearestNeighbors);


    }

	//! void destructor
    omplPRMPlanner::~omplPRMPlanner(){
			
	}
	
	//! setParameters sets the parameters of the planner
    bool omplPRMPlanner::setParameters(){

      omplPlanner::setParameters();
      try{
        HASH_S_K::iterator it = _parameters.find("MaxNearestNeighbors");
        if(it != _parameters.end()){
          _MaxNearestNeighbors = it->second;
          //ss->getPlanner()->as<myPRM>()->setMaxNearestNeighbors(_MaxNearestNeighbors);
          ss->getPlanner()->as<og::PRM>()->setMaxNearestNeighbors(_MaxNearestNeighbors);
        }
        else
          return false;

        it = _parameters.find("DistanceThreshold");
        if(it != _parameters.end()){
            _distanceThreshold = it->second;
            //ss->getPlanner()->as<myPRM>()->setConnectionFilter(boost::bind(&omplplanner::connectionDistanceFilter, _1,_2, _distanceThreshold, ss->getPlanner()));
            ss->getPlanner()->as<og::PRM>()->setConnectionFilter(boost::bind(&omplplanner::connectionDistanceFilter, _1,_2, _distanceThreshold, ss->getPlanner()));

      }
        else
          return false;

      }catch(...){
        return false;
      }
      return true;
    }
  }
}

#endif // KAUTHAM_USE_OMPL

