/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 

#if defined(KAUTHAM_USE_OMPL)

#include <ompl/base/SpaceInformation.h>
#include <ompl/base/OptimizationObjective.h>
#include <ompl/base/ProjectionEvaluator.h>
#include <ompl/base/spaces/RealVectorStateSpace.h>
#include "omplPCAalignmentOptimizationObjective.h"


#include <boost/numeric/ublas/matrix.hpp>
#include <boost/numeric/ublas/lu.hpp>
#include <boost/numeric/ublas/io.hpp>

#include <ompl/tools/config/MagicConstants.h>
#include <ompl/base/ScopedState.h>
#include <ompl/base/spaces/SE3StateSpace.h>
#include <ompl/base/spaces/RealVectorStateSpace.h>



using namespace boost::numeric::ublas;
namespace ob = ompl::base;
namespace om = ompl::magic;


namespace Kautham {
  namespace omplplanner{

    //http://savingyoutime.wordpress.com/2009/09/21/c-matrix-inversion-boostublas/
    /* Matrix inversion routine.
        Uses lu_factorize and lu_substitute in uBLAS to invert a matrix */
    template<class T>
        bool InvertMatrix(const matrix<T>& input, matrix<T>& inverse)
        {
        typedef permutation_matrix<std::size_t> pmatrix;

        // create a working copy of the input
        matrix<T> A(input);

        // create a permutation matrix for the LU-factorization
        pmatrix pm(A.size1());

        // perform LU-factorization
        int res = lu_factorize(A, pm);
        if (res != 0)
            return false;

        // create identity matrix of "inverse"
        inverse.assign(identity_matrix<T> (A.size1()));

        // backsubstitute to get the inverse
        lu_substitute(A, pm, inverse);

        return true;
    }


  //! Constructor
    PCAalignmentOptimizationObjective::PCAalignmentOptimizationObjective(const ob::SpaceInformationPtr &si, int dim, ob::ProjectionMatrix M) :
    ob::OptimizationObjective(si)
    {
        description_ = "PCA alignment";
        PCAdataset=false;
        dimension = dim;
        wpenalization = 1.0;
        wdistance = 0.1;
        worientation = 1.0;

        lambda.resize(dimension);
        pcaM.mat.resize(dimension,dimension);
        setPCAdata(M);
    }

    //! void destructor
    PCAalignmentOptimizationObjective::~PCAalignmentOptimizationObjective(){

    }



    //void PCAalignmentOptimizationObjective::setPCAdata(int option)//ob::ProjectionMatrix M, ob::EuclideanProjection v){
    void PCAalignmentOptimizationObjective::setPCAdata(ob::ProjectionMatrix M)
    {
/*
        //de moment ho fixo a ma
        Matrix pca(dimension,dimension);
        Matrix invpca(dimension,dimension);
        ob::EuclideanProjection vp(dimension);
        if(option==0)
        {
            pca(0,0) = sqrt(2.0)/2.0;
            pca(0,1) = sqrt(2.0)/2.0;
            pca(1,0) = -sqrt(2.0)/2.0;
            pca(1,1) = sqrt(2.0)/2.0;
            InvertMatrix(pca, invpca);
            pcaM.mat = invpca;
            pcaM.print();
        }
        else
        {
            pca(0,0) = sqrt(2.0)/2.0;
            pca(0,1) = -sqrt(2.0)/2.0;
            pca(1,0) = sqrt(2.0)/2.0;
            pca(1,1) = sqrt(2.0)/2.0;
            InvertMatrix(pca, invpca);
            pcaM.mat = invpca;
            pcaM.print();
        }

        vp[0] = 1.0;
        vp[1] = 0.1;
        lambda = vp;
        PCAdataset=true;
*/


        Matrix pca(dimension,dimension);
        Matrix invpca(dimension,dimension);


        double modul;
        for(int j=0;j<dimension;j++)//column
        {
            modul = 0.0;
            for(int i=0;i<dimension;i++)//row
            {
                pca(i,j) = M.mat(i,j);
                modul += M.mat(i,j)*M.mat(i,j);
            }
            lambda[j] = sqrt(modul);
            for(int i=0;i<dimension;i++) //columns vectors must be unitary vectors
                pca(i,j) /= lambda[j];
        }


        double k11 = pca(0,0);
        double k12 = pca(0,1);
        double k21 = pca(1,0);
        double k22 = pca(1,1);


        InvertMatrix(pca, invpca);
        pcaM.mat = invpca;
        pcaM.print();

        PCAdataset=true;

    }


    ob::Cost PCAalignmentOptimizationObjective::motionCost(const ob::State *s0, const ob::State *s1, const ob::State *s2) const
    {
        ob::StateSpacePtr space = getSpaceInformation()->getStateSpace();

        ob::ScopedState<ob::CompoundStateSpace> ss1(space);
        ob::ScopedState<ob::CompoundStateSpace> ss2(space);
        ss1 = *s1;
        ss2 = *s2;

        //Get the SE3 subspace of robot 0
        ob::StateSpacePtr ssRobot0 = ((ob::StateSpacePtr) space->as<ob::CompoundStateSpace>()->getSubspace(0));
        ob::StateSpacePtr ssRobot0SE3 =  ((ob::StateSpacePtr) space->as<ob::CompoundStateSpace>()->getSubspace(0));

        ob::ScopedState<ob::SE3StateSpace> s1se3(ssRobot0SE3);
        ss1 >> s1se3;
        ob::ScopedState<ob::SE3StateSpace> s2se3(ssRobot0SE3);
        ss2 >> s2se3;

        //convert to a vector of 7 components
        vector<double> s1_se3coords;
        vector<double> s2_se3coords;
        s1_se3coords.resize(2);
        s2_se3coords.resize(2);
        s1_se3coords[0] = s1se3->getX();
        s1_se3coords[1] = s1se3->getY();
        s2_se3coords[0] = s2se3->getX();
        s2_se3coords[1] = s2se3->getY();


        //vector from s1 to s2 in state space: from12 = s2-s1
        vector<double> from12(dimension);
        double modul12=0.0;
        for(int i=0; i<dimension;i++)
        {
            from12[i] = s2_se3coords[i] - s1_se3coords[i];
            modul12 += from12[i]*from12[i];
        }
        modul12 = sqrt(modul12);

        //vector from s1 to s2 using the pca reference frame: vpca = M*v
        ob::EuclideanProjection to12(dimension);
        pcaM.project(&from12[0],to12);

        /*
        //to[i] es la projeccio de l'edge en la direccio de l'eigenvector i (PMDi)
        //double alpha = acos(fabs(to12[0]/modul12));//angle entre l'edge i el  PMD0
        double orientcost=0.0;
        for(int i=0;i<dimension;i++)
            orientcost += lambda[i]*acos(fabs(to12[i]/modul12));//add the weighted component on the PMDi direction
        orientcost = orientcost*worientation*modul12;
        */

        //std::cout<<alpha<<" "<<modul<<std::endl;


        //normalize the lambdas (eignvalues).
        vector<double> lambdanorm;
        lambdanorm.resize(dimension);
        double lambdamax=0.0;
        //The first one is always the largest (it should be!). Chack it, perhaps they are not ordered....
        for(int i=0; i<dimension;i++)
        {
            if(lambda[i]>lambdamax) lambdamax=lambda[i];
        }
        for(int i=0; i<dimension;i++)
        {
            lambdanorm[i] = lambda[i] / lambdamax;
        }
        double modulto12=0.0;
        for(int i=0; i<dimension;i++)
        {
            modulto12 += to12[i]*to12[i]*lambdanorm[i]*lambdanorm[i];
        }
        modulto12 = sqrt(modulto12);
        //std::cout<<alpha<<" "<<modul12/modulto12<<std::endl;
        //when aligned with the main PMD the cost is zero ((1/lambdanorm1)-1 = 0)
        //when aligned with the second PMD the cost is ((1/lambdanorm2)-1)
        double alpha = (modul12/modulto12)-1.0;
        //modul12 should always be larger than modulto12 because the lambdas are normalized. Then alpha must be >= 0
        if(alpha<0)
        {
            alpha=0.0; //this should not happen
        }
        double orientcost=alpha*worientation*modul12;



        //Compute now the possible penalization due to a big change in orientation
        //double orientationpenalization=1.0;
        double orientationpenalization=0.0;
        if(s0!=NULL)
        {
            ob::ScopedState<ob::CompoundStateSpace> ss0(space);
            ss0 = *s0;
            ob::ScopedState<ob::SE3StateSpace> s0se3(ssRobot0SE3);
            ss0 >> s0se3;
            vector<double> s0_se3coords;
            s0_se3coords.resize(2);
            s0_se3coords[0] = s0se3->getX();
            s0_se3coords[1] = s0se3->getY();
            //vector from s0 to s1 in state space: from01 = s1-s0
            vector<double> from01(dimension);
            double modul01=0.0;
            for(int i=0; i<dimension;i++)
            {
                from01[i] = s1_se3coords[i] - s0_se3coords[i];
                modul01 += from01[i]*from01[i];
            }
            modul01 = sqrt(modul01);

            double cosbeta = (from01[0]*from12[0]+from01[1]*from12[1])/(modul01*modul12);
            orientationpenalization = acos(cosbeta)*wpenalization*modul12;
        }

        double distcost = wdistance*modul12;
        std::cout<<" d="<<distcost<<" o="<<orientcost<<" p="<<orientationpenalization<<" "<<std::endl;
        return ob::Cost(distcost+orientcost+orientationpenalization);
    }


    ob::Cost PCAalignmentOptimizationObjective::motionCost(const ob::State *s1, const ob::State *s2) const
    {
        motionCost(NULL,s1,s2);
    }


  /////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////
    /*

  //! Constructor
    PCAalignmentOptimizationObjective3::PCAalignmentOptimizationObjective3(const ob::SpaceInformationPtr &si, int dim) :
    ob::MechanicalWorkOptimizationObjective(si)
    {
        description_ = "PCA alignment2";
        PCAdataset=false;
        dimension = dim;

        //de moment ho fixem a 2
        dimension = 2;
        setPCAdata(0);
    }

    //! void destructor
    PCAalignmentOptimizationObjective3::~PCAalignmentOptimizationObjective3(){

    }

    void PCAalignmentOptimizationObjective3::setPCAdata(int option)//ob::ProjectionMatrix M, ob::EuclideanProjection v){
    {
        //de moment ho fixo a ma
        Matrix pca(dimension,dimension);
        Matrix invpca(dimension,dimension);
        ob::EuclideanProjection v(dimension);
        bari.resize(dimension);

        if(option==0)
        {
            pca(0,0) = sqrt(2.0)/2.0;
            pca(0,1) = sqrt(2.0)/2.0;
            pca(1,0) = -sqrt(2.0)/2.0;
            pca(1,1) = sqrt(2.0)/2.0;
            InvertMatrix(pca, invpca);
            pcaM.mat = invpca;
            pcaM.print();
        }
        else
        {
            pca(0,0) = sqrt(2.0)/2.0;
            pca(0,1) = -sqrt(2.0)/2.0;
            pca(1,0) = sqrt(2.0)/2.0;
            pca(1,1) = sqrt(2.0)/2.0;
            InvertMatrix(pca, invpca);
            pcaM.mat = invpca;
            pcaM.print();
        }

        v[0] = 1.0;
        v[1] = 0.1;
        lambda = v;

        bari[0]=0.5;
        bari[1]=0.5;
        PCAdataset=true;
    }

    ob::Cost PCAalignmentOptimizationObjective3::motionCost(const ob::State *s1, const ob::State *s2) const
    {
      // Only accrue positive changes in cost
      double positiveCostAccrued = std::max(stateCost(s2).v - stateCost(s1).v, 0.0);
      return ob::Cost(wfix*positiveCostAccrued/si_->distance(s1,s2) + wdistance*si_->distance(s1,s2));
    }

    ob::Cost PCAalignmentOptimizationObjective3::stateCost(const ob::State *s1) const
    {
        ob::StateSpacePtr space = getSpaceInformation()->getStateSpace();

        ob::ScopedState<ob::CompoundStateSpace> ss1(space);
        ss1 = *s1;

        //Get the SE3 subspace of robot 0
        ob::StateSpacePtr ssRobot0 = ((ob::StateSpacePtr) space->as<ob::CompoundStateSpace>()->getSubspace(0));
        ob::StateSpacePtr ssRobot0SE3 =  ((ob::StateSpacePtr) space->as<ob::CompoundStateSpace>()->getSubspace(0));
        ob::ScopedState<ob::SE3StateSpace> s1se3(ssRobot0SE3);
        ss1 >> s1se3;

        //convert to a vector of 7 components
        vector<double> s1_se3coords;
        s1_se3coords.resize(2);
        s1_se3coords[0] = s1se3->getX();
        s1_se3coords[1] = s1se3->getY();

        vector<double> from;
        from.resize(dimension);
        for(int i=0; i<dimension;i++)
        {
            from[i] = s1_se3coords[i] - bari[i];
        }

        //vector from s1 to s2 using the pca reference frame: vpca = M*v
        ob::EuclideanProjection to(dimension);
        pcaM.project(&from[0],to);

        double dist=0.0;
        for(int i=0; i<dimension;i++)
        {
            dist += (to[i]/lambda[i])*(to[i]/lambda[i]);
        }
        dist = sqrt(dist);
        return ob::Cost(dist);
    }
  */
  }
}


#endif // KAUTHAM_USE_OMPL
