/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 
 

#include <libproblem/workspace.h>
#include <libsampling/sampling.h>
#include "localplanner.h"
#include "gridplanner.h"

using namespace libSampling;

namespace libPlanner {
  namespace gridplanner{

    gridPlanner::gridPlanner(SPACETYPE stype, Sample *init, Sample *goal, SampleSet *samples, Sampler *sampler, WorkSpace *ws, LocalPlanner *lcPlan, KthReal ssize):
              Planner(stype, init, goal, samples, sampler, ws, lcPlan, ssize)
	{
		//set intial values
		_stepsDiscretization = 4;
	    _maxNumSamples = (int)pow((float)_stepsDiscretization, _wkSpace->getDimension());

		//set intial values from parent class data
		_speedFactor = 1;
		_solved = false;
		setStepSize(ssize);//also changes stpssize of localplanner
	  
		_guiName = "Grid Planner";
		addParameter("Step Size", ssize);
		addParameter("Speed Factor", _speedFactor);
        addParameter("Max. Samples", _maxNumSamples);
		addParameter("Discr. Steps", _stepsDiscretization);

		_samples->clear();
		discretizeCspace();
    }

	gridPlanner::~gridPlanner(){
			
	}
	
		void  gridPlanner::loadgrid(vector<KthReal> &coords, int coord_i)
		{
			KthReal delta = 1.0/_stepsDiscretization;
			KthReal offset = delta/2;
			for(int j=0; j<_stepsDiscretization; j++) 
			{
				coords[coord_i] = offset + j*delta;
				//if not last coordinate, continue  
				if(coord_i != _wkSpace->getDimension()-1) 
				{
					loadgrid(coords, coord_i + 1);	
				}
				//loadgrid called with last coordinate, i.e. the coords of a cell are completed
				else
				{
					Sample *smp = new Sample(_wkSpace->getDimension());
					smp->setCoords(coords);
					/* collisioncheck and print info  
					cout<<"sample "<<_samples->getSize()<<": ";
					for(int i=0;i<_wkSpace->getDimension();i++) cout<<coords[i]<<", ";
					if(_wkSpace->collisionCheck(smp) == true)
						cout<<"COLLISION - color = "<<smp->getcolor()<<endl;
					else 
						cout<< "FREE - color = "<<smp->getcolor()<<endl;
					*/
					_wkSpace->collisionCheck(smp);
					_samples->add(smp);
				}
			}
		}


		void  gridPlanner::connectgrid(vector<int> &index, int coord_i)
		{
			for(int j=0; j<_stepsDiscretization; j++) 
			{
				index[coord_i] = j;
				//if not last coordinate, continue  
				if(coord_i != _wkSpace->getDimension()-1) 
				{
					connectgrid(index, coord_i + 1);	
				}
				//connectgrid called with last coordinate, i.e. the indices of a cell are completed
				else
				{
					//find sample number from indices
					int smplabel = 0;
					for(int k=0;k<_wkSpace->getDimension();k++) 
						smplabel += (int)pow((float)_stepsDiscretization,k)*index[k];
					
					//sweep for all directions
					for(int n=0;n<_wkSpace->getDimension();n++)
					{
						//find eighbor samples number from indices
						int smplabelneighplus = 0;
						bool plusneighexists = true;
						for(int k=0;k<_wkSpace->getDimension();k++) 
						{
							if(k==n) 
							{
								if(index[k]+1 >= _stepsDiscretization) plusneighexists = false;
								smplabelneighplus  += (int)pow((float)_stepsDiscretization,k)*(index[k]+1);
							}
							else
							{
								smplabelneighplus  += (int)pow((float)_stepsDiscretization,k)*index[k];
							}
						}
						//connect samples
						if(plusneighexists==true)
						{
							gridEdge *e;
							e = new gridEdge(smplabel, smplabelneighplus);
							edges.push_back(e);
							if(_samples->getSampleAt(smplabel)->isFree()==false || 
							   _samples->getSampleAt(smplabelneighplus)->isFree()==false) 
								weights.push_back(-1.0);
							else 
								weights.push_back(1.0);
						}
					}
				}
			}


		}


		
		void  gridPlanner::prunegrid()
		{
			negative_edge_weight<WeightMap> filter(get(edge_weight, *g));

			fg = new filteredGridGraph(*g, filter);
		}

		void  gridPlanner::discretizeCspace()
		{
			vector<KthReal> coords(_wkSpace->getDimension());
			//collision-check cells
			loadgrid(coords, 0);
			//connedt neighbor cells
			vector<int> index(_wkSpace->getDimension());
			connectgrid(index, 0);
			//create grid as graph
			loadGraph();

			/*verification intial values of potential */
			cout<<"POTENTIAL:";
			for(unsigned int i=0;i<num_vertices(*g); i++) 
				cout<<getPotential(i)<<", ";
			cout<<endl;
			cout<<endl;

			
			prunegrid();
			graph_traits<filteredGridGraph>::edge_iterator i, end;
			for(tie(i,end)=boost::edges(*fg); i!=end; ++i)
			{
				gridVertex s=source(*i,*fg);
				gridVertex t=target(*i,*fg);
				cout<<"edge "<<*i<< " from "<< s<< " to "<<t<<endl;
			}
		}


    void gridPlanner::clearGraph(){
  		weights.clear();
	    edges.clear();
		_samples->clearNeighs();
	    if(_isGraphSet){
		    locations.clear();
		    delete g;
		    delete fg;
	    }
	    _isGraphSet = false;
		 _solved = false;
    }
  
    void gridPlanner::loadGraph()
	{
	    int maxNodes = this->_samples->getSize();
		unsigned int num_edges = edges.size(); 
      
		// create graph
		g = new gridGraph(maxNodes);
		WeightMap weightmap = get(edge_weight, *g);

		for(std::size_t j = 0; j < num_edges; ++j) 
		{
			edge_descriptor e; 
			bool inserted;//when the efge already exisits or is a self-loop
						  //then this flag is set to false and the edge is not inserted 
			tie(e, inserted) = add_edge(edges[j]->first,edges[j]->second, *g);
			if(inserted) weightmap[e] = weights[j];
		}

		//locations are the pointer to the samples of cspace that 
		//are at each node of the graph and is used to compute the
		//distance when using the heuristic (function distance_heuristic)
		for(unsigned int i=0;i<num_vertices(*g); i++)
		    locations.push_back( _samples->getSampleAt(i) );

		//set potential variable
		potmap = get(potential_value_t(), *g);
		
        LCPRNG* rgen = new LCPRNG(15485341);//15485341 is a big prime number
		for(unsigned int i=0;i<num_vertices(*g); i++)
		{
			if(locations[i]->isFree()==true)
			{
				setPotential(i, rgen->d_rand()); //random initialization of potential
			}
			else setPotential(i, 10);
		}


		_isGraphSet = true;
	}

  }
}


