/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 
 

#if defined(KAUTHAM_USE_OMPL)
#include <libproblem/workspace.h>
#include <libsampling/sampling.h>

#include <boost/bind/mem_fn.hpp>
#include <ompl/base/spaces/SE2StateSpace.h>

#include "omplcRRTcarplanner.h"




using namespace libSampling;

namespace libPlanner {
  namespace omplcplanner{


  /// Model defining the motion of the robot
  class KinematicCarModel
  {
  public:

      KinematicCarModel(const ob::StateSpace *space) : space_(space), carLength_(0.2)
      {
      }

      /// implement the function describing the robot motion: qdot = f(q, u)
      void operator()(const ob::State *state, const oc::Control *control, std::valarray<double> &dstate) const
      {
          const double *u = control->as<oc::RealVectorControlSpace::ControlType>()->values;
          const double theta = state->as<ob::RealVectorStateSpace::StateType>()->values[2];
          //const double theta = state->as<ob::SE2StateSpace::StateType>()->getYaw();

          dstate.resize(3);
          dstate[0] = u[0] * cos(theta*2*M_PI);
          dstate[1] = u[0] * sin(theta*2*M_PI);
          dstate[2] = u[0] * tan(u[1]*2*M_PI) / carLength_;
      }

      /// implement y(n+1) = y(n) + d
      void update(ob::State *state, const std::valarray<double> &dstate) const
      {
          //ob::SE2StateSpace::StateType &s = *state->as<ob::SE2StateSpace::StateType>();
          //s.setX(s.getX() + dstate[0]);
          //s.setY(s.getY() + dstate[1]);
          //s.setYaw(s.getYaw() + dstate[2]);
          //space_->enforceBounds(state);

          ob::RealVectorStateSpace::StateType &s = *state->as<ob::RealVectorStateSpace::StateType>();
          s.values[0] = s.values[0] + dstate[0];
          s.values[1] = s.values[1] + dstate[1];
          s.values[2] = s.values[2] + dstate[2];
          if(s.values[2]<0.0)
          {
             s.values[2] = 1.0 - s.values[2];
          }
          else if(s.values[2]>1.0)
          {
             s.values[2] = s.values[2] - 1.0;
          }

          space_->enforceBounds(state);
      }

      void setCarLength(double d)
      {
          carLength_ = d;
      }

      double getCarLength()
      {
          return carLength_;
      }

  private:

      const ob::StateSpace *space_;
      double             carLength_;

  };


  /// Simple integrator: Euclidean method
  template<typename F>
  class EulerIntegrator
  {
  public:

      EulerIntegrator(const ob::StateSpace *space, double timeStep) : space_(space), timeStep_(timeStep), ode_(space)
      {
      }

      void propagate(const ob::State *start, const oc::Control *control, const double duration, ob::State *result) const
      {
          double t = timeStep_;
          std::valarray<double> dstate;
          space_->copyState(result, start);
          while (t < duration + std::numeric_limits<double>::epsilon())
          {
              ode_(result, control, dstate);
              ode_.update(result, timeStep_ * dstate);
              t += timeStep_;
          }
          if (t + std::numeric_limits<double>::epsilon() > duration)
          {
              ode_(result, control, dstate);
              ode_.update(result, (t - duration) * dstate);
          }
      }

      double getTimeStep(void) const
      {
          return timeStep_;
      }

      void setTimeStep(double timeStep)
      {
          timeStep_ = timeStep;
      }

      F* getOde()
      {
          return &ode_;
      }

  private:

      const ob::StateSpace *space_;
      double                   timeStep_;
      F                        ode_;

  };



  class DemoControlSpace : public oc::RealVectorControlSpace
  {
  public:

      DemoControlSpace(const ob::StateSpacePtr &stateSpace) : oc::RealVectorControlSpace(stateSpace, 2)
      {
      }
  };

  class DemoStatePropagator : public oc::StatePropagator
  {
  public:

      DemoStatePropagator(const oc::SpaceInformationPtr &si) : oc::StatePropagator(si),
                                                               integrator_(si->getStateSpace().get(), 0.0)
      {
      }

      virtual void propagate(const ob::State *state, const oc::Control* control, const double duration, ob::State *result) const
      {
          integrator_.propagate(state, control, duration, result);
      }

      void setIntegrationTimeStep(double timeStep)
      {
          integrator_.setTimeStep(timeStep);
      }

      double getIntegrationTimeStep(void) const
      {
          return integrator_.getTimeStep();
      }

      EulerIntegrator<KinematicCarModel> *getIntegrator()
      {
          return &integrator_;
      }

      EulerIntegrator<KinematicCarModel> integrator_;
  };

	//! Constructor
    omplcRRTcarPlanner::omplcRRTcarPlanner(SPACETYPE stype, Sample *init, Sample *goal, SampleSet *samples, Sampler *sampler, WorkSpace *ws, LocalPlanner *lcPlan, KthReal ssize):
              omplcPlanner(stype, init, goal, samples, sampler, ws, lcPlan, ssize)
	{
        _guiName = "ompl cRRT Planner";
        _idName = "omplcRRTcar";

  // construct the state space we are planning in
 // space =  ((ob::StateSpacePtr) new ob::SE2StateSpace());

  // set the bounds for the R^2 part of SE(2)
  //ob::RealVectorBounds bounds(2);
  //bounds.setLow(0);
  //bounds.setHigh(1);

  //space->as<ob::SE2StateSpace>()->setBounds(bounds);


        // create a control space
        spacec = ((oc::ControlSpacePtr) new DemoControlSpace(space));

        // set the bounds for the control space
        _controlBound_Tras = 0.3;
        _controlBound_Rot = 0.03;
        _onlyForward = 1;
        addParameter("ControlBound_Tras", _controlBound_Tras);
        addParameter("ControlBound_Rot", _controlBound_Rot);
        addParameter("OnlyForward (0/1)", _onlyForward);
        ob::RealVectorBounds cbounds(2);
        cbounds.setLow(0, - _controlBound_Tras * (1 - _onlyForward));
        cbounds.setHigh(0, _controlBound_Tras);
        cbounds.setLow(1, -_controlBound_Rot);
        cbounds.setHigh(1, _controlBound_Rot);
        spacec->as<DemoControlSpace>()->setBounds(cbounds);

        // define a simple setup class
        ss = ((oc::SimpleSetupPtr) new oc::SimpleSetup(spacec));

        // set state validity checking for this space
        ss->setStateValidityChecker(boost::bind(&omplcplanner::isStateValid, ss->getSpaceInformation().get(), _1, (Planner*)this));

        // set the propagation routine for this space
        oc::SpaceInformationPtr si=ss->getSpaceInformation();
        ss->setStatePropagator(oc::StatePropagatorPtr(new DemoStatePropagator(si)));

        // propagation step size
        _propagationStepSize = 0.01;
        _duration = 1;
        addParameter("PropagationStepSize", _propagationStepSize);
        addParameter("Duration", _duration);
        static_cast<DemoStatePropagator*>(ss->getStatePropagator().get())->setIntegrationTimeStep(_propagationStepSize);
        si->setPropagationStepSize(_propagationStepSize*_duration);

        //carLength
        _carLength = 0.2;
        addParameter("CarLength", _carLength);
        static_cast<DemoStatePropagator*>(ss->getStatePropagator().get())->getIntegrator()->getOde()->setCarLength(_carLength);


        // create a planner for the defined space
        ob::PlannerPtr planner(new oc::RRT(si));
        ss->setPlanner(planner);

        _GoalBias=(planner->as<oc::RRT>())->getGoalBias();
        addParameter("Goal Bias", _GoalBias);
        ss->getPlanner()->as<oc::RRT>()->setGoalBias(_GoalBias);

        //kautham step size used when discretizing the path for visualizatuin,
        //set very big, then simulatuionpath = path. This is ok since this planner generates a fine discretization path
        //and in this way we aviod interpolating orientations when moving form e.g. 2º to -1º=359º.
        _stepSize = 10000;

    }

	//! void destructor
    omplcRRTcarPlanner::~omplcRRTcarPlanner(){
			
	}
	
	//! setParameters sets the parameters of the planner
    bool omplcRRTcarPlanner::setParameters(){

      omplcPlanner::setParameters();
      try{
        HASH_S_K::iterator it = _parameters.find("Goal Bias");
        if(it != _parameters.end()){
            _GoalBias = it->second;
            ss->getPlanner()->as<oc::RRT>()->setGoalBias(_GoalBias);
        }
        else
          return false;

        it = _parameters.find("Goal Bias");
                if(it != _parameters.end()){
                    _GoalBias = it->second;
                    ss->getPlanner()->as<oc::RRT>()->setGoalBias(_GoalBias);
                }
                else
                  return false;



        it = _parameters.find("Duration");
            if(it != _parameters.end()){
                _duration = it->second;
                ss->getSpaceInformation()->setPropagationStepSize(_propagationStepSize*_duration);
            }
            else
                return false;

       it = _parameters.find("PropagationStepSize");
                if(it != _parameters.end()){
                     _propagationStepSize = it->second;
                     static_cast<DemoStatePropagator*>(ss->getStatePropagator().get())->setIntegrationTimeStep(_propagationStepSize);
                     ss->getSpaceInformation()->setPropagationStepSize(_propagationStepSize*_duration);
                }
                else
                    return false;

       it = _parameters.find("CarLength");
                if(it != _parameters.end()){
                    _carLength = it->second;
                    static_cast<DemoStatePropagator*>(ss->getStatePropagator().get())->getIntegrator()->getOde()->setCarLength(_carLength);

                }
                else
                    return false;





        it = _parameters.find("ControlBound_Tras");
                if(it != _parameters.end()){
                             _controlBound_Tras = it->second;
                             ob::RealVectorBounds cbounds(2);
                             cbounds.setLow(0, - _controlBound_Tras * (1 - _onlyForward));
                             cbounds.setHigh(0, _controlBound_Tras);
                             cbounds.setLow(1, -_controlBound_Rot);
                             cbounds.setHigh(1, _controlBound_Rot);
                             spacec->as<DemoControlSpace>()->setBounds(cbounds);
                }
                else
                   return false;

        it = _parameters.find("ControlBound_Rot");
               if(it != _parameters.end()){
                      _controlBound_Rot = it->second;
                      ob::RealVectorBounds cbounds(2);
                      cbounds.setLow(0, - _controlBound_Tras * (1 - _onlyForward));
                      cbounds.setHigh(0, _controlBound_Tras);
                      cbounds.setLow(1, -_controlBound_Rot);
                      cbounds.setHigh(1, _controlBound_Rot);
                      spacec->as<DemoControlSpace>()->setBounds(cbounds);
                }
                else
                   return false;

        it = _parameters.find("OnlyForward (0/1)");
                if(it != _parameters.end()){
                    if(it->second != 0) _onlyForward=1;
                    else _onlyForward=0;

                    ob::RealVectorBounds cbounds(2);
                    cbounds.setLow(0, - _controlBound_Tras * (1 - _onlyForward));
                    cbounds.setHigh(0, _controlBound_Tras);
                    cbounds.setLow(1, -_controlBound_Rot);
                    cbounds.setHigh(1, _controlBound_Rot);
                    spacec->as<DemoControlSpace>()->setBounds(cbounds);
                }
                else
                   return false;



      }catch(...){
        return false;
      }
      return true;
    }
  }
}


#endif // KAUTHAM_USE_OMPL
