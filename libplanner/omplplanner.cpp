/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 

#if defined(KAUTHAM_USE_OMPL)

#include <libproblem/workspace.h>
#include <libsampling/sampling.h>

#include <boost/bind/mem_fn.hpp>

#include "localplanner.h"
#include "omplplanner.h"


#include <Inventor/nodes/SoTransform.h>
#include <Inventor/nodes/SoCoordinate3.h>
#include <Inventor/nodes/SoCube.h>
#include <Inventor/nodes/SoPointSet.h>
#include <Inventor/nodes/SoLineSet.h>


using namespace libSampling;

namespace libPlanner {
  namespace omplplanner{

  bool isStateValid(const ob::State *state, Planner *p)//, Sample *smp)
  {
      return true;
      /*
      const ob::RealVectorStateSpace::StateType *R2state = state->as<ob::RealVectorStateSpace::StateType>();
      int d = p->wkSpace()->getDimension();
      Sample *smp = new Sample(d);
      vector<KthReal> coords;
      coords.resize(d);
      for(int i=0;i<d;i++)
        coords[i] = R2state->values[i];
      smp->setCoords(coords);
      if( p->wkSpace()->collisionCheck(smp) )
          return false;
      return true;
      */
  }


  ////////////////////////////////////////////77
  /*
      weightedRealVectorStateSpace::weightedRealVectorStateSpace(unsigned int dim = 0) : RealVectorStateSpace(dim)
      {
          for(int i=0; i<dim; i++)
          {
              weights.push_back(1.0);
          }
      };

      weightedRealVectorStateSpace::weightedRealVectorStateSpace(unsigned int dim = 0, vector<KthReal> w) : RealVectorStateSpace(dim)
      {
          for(int i=0; i<dim; i++)
          {
              weights.push_back(w[i]);
          }
      };



      weightedRealVectorStateSpace::distance(const State *state1, const State *state2) const
      {
         double dist = 0.0;
         const double *s1 = static_cast<const StateType*>(state1)->values;
         const double *s2 = static_cast<const StateType*>(state2)->values;

        for (unsigned int i = 0 ; i < dimension_ ; ++i)
        {
            double diff = ((*s1++) - (*s2++))*weights[i];
            dist += diff * diff;
        }
        return sqrt(dist);
      };
      */

//////////////////////////////////////////////////////

	//! Constructor
    omplPlanner::omplPlanner(SPACETYPE stype, Sample *init, Sample *goal, SampleSet *samples, Sampler *sampler, WorkSpace *ws, LocalPlanner *lcPlan, KthReal ssize):
              Planner(stype, init, goal, samples, sampler, ws, lcPlan, ssize)
	{
		//set intial values
        _planningTime = 10;

		//set intial values from parent class data
		_speedFactor = 1;
        _solved = false;
        _stepSize = ssize;
	  
        _guiName = "ompl Planner";
        _idName = "ompl Planner";
        addParameter("Step Size", ssize);
        addParameter("Speed Factor", _speedFactor);
        addParameter("Max Planning Time", _planningTime);

        // construct the state space we are planning in
        vector<ob::StateSpacePtr> spaceRn;
        vector<ob::StateSpacePtr> spaceSE3;
        vector<ob::StateSpacePtr> spaceRob;
        vector< double > weights;

        spaceRn.resize(_wkSpace->robotsCount());
        spaceSE3.resize(_wkSpace->robotsCount());
        spaceRob.resize(_wkSpace->robotsCount());
        weights.resize(_wkSpace->robotsCount());


        for(int i=0; i<_wkSpace->robotsCount(); i++)
        {

            vector<ob::StateSpacePtr> compoundspaceRob;
            vector< double > weightsRob;
            std::stringstream sstm;

            //create state space SE3 for the mobile base, if necessary
            if(_wkSpace->getRobot(i)->isSE3Enabled())
            {
                spaceSE3[i] = ((ob::StateSpacePtr) new ob::SE3StateSpace());

                sstm << "ssRobot" << i<<"_SE3";
                spaceSE3[i]->setName(sstm.str());
                // set the bounds

                ob::RealVectorBounds bounds(3);
                bounds.setLow(0, _wkSpace->getRobot(i)->getLimits(0)[0]);
                bounds.setLow(1, _wkSpace->getRobot(i)->getLimits(1)[0]);
                bounds.setLow(2, _wkSpace->getRobot(i)->getLimits(2)[0]);
                bounds.setHigh(0, _wkSpace->getRobot(i)->getLimits(0)[1]);
                bounds.setHigh(1, _wkSpace->getRobot(i)->getLimits(1)[1]);
                bounds.setHigh(2, _wkSpace->getRobot(i)->getLimits(2)[1]+0.00001);
                spaceSE3[i]->as<ob::SE3StateSpace>()->setBounds(bounds);

                //sets the weights between translation and rotation
                spaceSE3[i]->as<ob::SE3StateSpace>()->setSubspaceWeight(0,_wkSpace->getRobot(i)->getWeightSE3()[0]);//translational weight
                spaceSE3[i]->as<ob::SE3StateSpace>()->setSubspaceWeight(1,_wkSpace->getRobot(i)->getWeightSE3()[1]);//rotational weight

                compoundspaceRob.push_back(spaceSE3[i]);
                weightsRob.push_back(1);
            }

            //create the Rn state space for the kinematic chain, if necessary
            if(_wkSpace->getRobot(i)->getNumJoints()>1)
            {
                spaceRn[i] = ((ob::StateSpacePtr) new ob::RealVectorStateSpace(_wkSpace->getRobot(i)->getNumJoints()));
                sstm << "ssRobot" << i<<"_Rn";
                spaceRn[i]->setName(sstm.str());
                // set the bounds
                ob::RealVectorBounds bounds(_wkSpace->getRobot(i)->getNumJoints());
                for(int j=0; j<_wkSpace->getRobot(i)->getNumJoints();j++)
                {
                    bounds.setLow(j, *_wkSpace->getRobot(i)->getLink(j)->getLimits(true));//low limit
                    bounds.setHigh(j,*_wkSpace->getRobot(i)->getLink(j)->getLimits(false));//high limit
                }
                spaceRn[i]->as<ob::RealVectorStateSpace>()->setBounds(bounds);

                compoundspaceRob.push_back(spaceRn[i]);
                weightsRob.push_back(1);
            }
            //the compound state space (SE3xRn), either SE3 or Rn may be missing
            spaceRob[i] = ((ob::StateSpacePtr) new ob::CompoundStateSpace(compoundspaceRob,weightsRob));
            weights[i] = 1;
            sstm.str("");
            sstm << "ssRobot" << i;
            spaceRob[i]->setName(sstm.str());
        }

        //the state space for the set of robots
        space = ((ob::StateSpacePtr) new ob::CompoundStateSpace(spaceRob,weights));


        //The derived classes will create a planner,
        //the simplesetup and call the setStateValididyChecker function



        /****************************************************************************
//PROVES PER OMPLIR UN COMPUND STATE SPACE...


        ob::StateSpacePtr myspaceSE3;
        ob::StateSpacePtr myspaceRn;
        vector<ob::StateSpacePtr> mycompoundvector;
        vector< double > myweightsRob;

        //////////////////////////////////
        //The SE3 space for the mobile base
        myspaceSE3 = ((ob::StateSpacePtr) new ob::SE3StateSpace());
        // set the bounds
        ob::RealVectorBounds myse3bounds(3);
        myse3bounds.setLow(0, 0.0);
        myse3bounds.setLow(1, 0.0);
        myse3bounds.setLow(2, 0.0);
        myse3bounds.setHigh(0, 1.0);
        myse3bounds.setHigh(1, 1.0);
        myse3bounds.setHigh(2, 1.0);
        myspaceSE3->as<ob::SE3StateSpace>()->setBounds(myse3bounds);
        //prepare the vectors to set up the compound state space
        mycompoundvector.push_back(myspaceSE3);
        myweightsRob.push_back(1);

        //////////////////////////////////
        //The Rn space for the kinematic chain of the arm
        int numjoints = 6;
        myspaceRn = ((ob::StateSpacePtr) new ob::RealVectorStateSpace(numjoints));
        // set the bounds
        ob::RealVectorBounds myrnbounds(numjoints);
        for(int i=0; i<numjoints;i++)
        {
            myrnbounds.setLow(i, 0.0);
            myrnbounds.setHigh(i,1.0);
        }
        myspaceRn->as<ob::RealVectorStateSpace>()->setBounds(myrnbounds);
        //prepare the vectors to set up the compound state space
        mycompoundvector.push_back(myspaceRn);
        myweightsRob.push_back(1);

        //////////////////////////////////
        //The compound state space for the mobile manipulator
        ob::StateSpacePtr mycompoundspaceRob;
        mycompoundspaceRob = ((ob::StateSpacePtr) new ob::CompoundStateSpace(mycompoundvector,myweightsRob));


        //////////////////////////////////
        //Set the start configuration
        ob::ScopedState<ob::CompoundStateSpace> mystartompl(mycompoundspaceRob);

        //Set the SE3 part
        ob::StateSpacePtr ssRobotiSE3 =  ((ob::StateSpacePtr) mycompoundspaceRob->as<ob::CompoundStateSpace>()->getSubspace(0));
        ob::ScopedState<ob::SE3StateSpace> cstartse3(ssRobotiSE3);
        cstartse3->setX(1.0);
        cstartse3->setY(2.0);
        cstartse3->setZ(3.0);
        cstartse3->rotation().setAxisAngle(0.0, 0.0, 1.0,0.5);
        //mystartompl[ssRobotiSE3] = cstartse3.get();
        //mystartompl[ssRobotiSE3].get() << cstartse3.get();
        mystartompl << cstartse3;
        //ob::operator<< (mystartompl, cstartse3);
//        mystartompl[ssRobotiSE3]->as<ob::SE3StateSpace::StateType>()->setX(1.0);
//        mystartompl[ssRobotiSE3]->as<ob::SE3StateSpace::StateType>()->setX(2.0);
//        mystartompl[ssRobotiSE3]->as<ob::SE3StateSpace::StateType>()->setX(3.0);
//        mystartompl[ssRobotiSE3]->as<ob::SE3StateSpace::StateType>()->rotation().setAxisAngle(0.0, 0.0, 1.0,0.5);

        //Set the Rn part
        ob::StateSpacePtr ssRobotiRn =  ((ob::StateSpacePtr) mycompoundspaceRob->as<ob::CompoundStateSpace>()->getSubspace(1));
        ob::ScopedState<ob::RealVectorStateSpace> cstartrn(ssRobotiRn);
        for(int j=0; j<numjoints;j++)
        {
            cstartrn[j] = 0.0;
            //(*mystartompl[ssRobotiRn]->as<ob::RealVectorStateSpace::StateType>())[j] = 0.0;
        }
        //mystartompl[ssRobotiRn] = cstartrn.get();
        mystartompl << cstartrn;

        cout<<"cstartse3:"<<endl;
        cstartse3.print();
        cout<<"cstartrn:"<<endl;
        cstartrn.print();

        cout<<"startompl:"<<endl;
        mystartompl.print();
*****************************************************************************/


    }

	//! void destructor
    omplPlanner::~omplPlanner(){
			
	}
	
	//! setParameters sets the parameters of the planner
    bool omplPlanner::setParameters(){
      try{
        HASH_S_K::iterator it = _parameters.find("Speed Factor");
        if(it != _parameters.end())
          _speedFactor = it->second;
        else
          return false;

        it = _parameters.find("Max Planning Time");
        if(it != _parameters.end())
            _planningTime = it->second;
        else
          return false;

        it = _parameters.find("Step Size");
        if(it != _parameters.end())
             _stepSize = it->second;
        else
          return false;

      }catch(...){
        return false;
      }
      return true;
    }

  	
    SoSeparator *omplPlanner::getIvCspaceScene()
    {
        if(_wkSpace->getDimension()==2)
        {
            //_sceneCspace = ((IVWorkSpace*)_wkSpace)->getIvScene();
            _sceneCspace = new SoSeparator();
        }
        else _sceneCspace=NULL;
        return Planner::getIvCspaceScene();
    }


    //This routine allows to draw the roadmap or tree for a sigle robot with 2 dof
    void omplPlanner::drawCspace()
    {
        if(_sceneCspace==NULL) return;

        if(_wkSpace->getDimension()==2)
        {
            //drawCspaceRn();
            drawCspaceSE3();
        }
    }


    //This routine allows to draw the roadmap or tree for a sigle robot with 2 dof
    void omplPlanner::drawCspaceSE3()
    {
            //first delete whatever is already drawn
            while (_sceneCspace->getNumChildren() > 0)
            {
                _sceneCspace->removeChild(0);
            }


            //draw points
            SoSeparator *psep = new SoSeparator();
            SoCoordinate3 *points  = new SoCoordinate3();
            SoPointSet *pset  = new SoPointSet();

            const ob::RealVectorStateSpace::StateType *pos;
            const ob::SE3StateSpace::StateType *se3state;
            ob::ScopedState<ob::CompoundStateSpace> pathscopedstate(space);

            //KthReal xmin=100000000.0;
            //KthReal xmax=-100000000.0;
            //KthReal ymin=100000000.0;
            //KthReal ymax=-100000000.0;


            ob::StateSpacePtr ssRoboti = ((ob::StateSpacePtr) space->as<ob::CompoundStateSpace>()->getSubspace(0));
            ob::StateSpacePtr ssRobotiSE3 =  ((ob::StateSpacePtr) ssRoboti->as<ob::CompoundStateSpace>()->getSubspace(0));


            KthReal xmin=ssRobotiSE3->as<ob::SE3StateSpace>()->getBounds().low[0];
            KthReal xmax=ssRobotiSE3->as<ob::SE3StateSpace>()->getBounds().high[0];
            KthReal ymin=ssRobotiSE3->as<ob::SE3StateSpace>()->getBounds().low[1];
            KthReal ymax=ssRobotiSE3->as<ob::SE3StateSpace>()->getBounds().high[1];

            KthReal x,y;

            ob::PlannerDataPtr pdata;
            pdata = ((ob::PlannerDataPtr) new ob::PlannerData(ss->getSpaceInformation()));
            ss->getPlanner()->getPlannerData(*pdata);

            for(int i=0;i<pdata->numVertices();i++)
            {

                pathscopedstate = pdata->getVertex(i).getState()->as<ob::CompoundStateSpace::StateType>();
                ob::ScopedState<ob::SE3StateSpace> pathscopedstatese3(ssRobotiSE3);
                pathscopedstate >> pathscopedstatese3;
                //ob::SE3StateSpace::StateType *pse3 = pathscopedstatese3.get();
                x = pathscopedstatese3->getX();
                y = pathscopedstatese3->getY();

                /*
                se3state = pdata->getVertex(i).getState()->as<ob::SE3StateSpace::StateType>();
                pos = se3state->as<ob::RealVectorStateSpace::StateType>(0);
                x=pos->values[0];
                y=pos->values[1];
                double xx=pos->values[0];
                double  yy=pos->values[1];
                */

                points->point.set1Value(i,x,y,0);

                //if(x<xmin) xmin=x;
                //if(x>xmax) xmax=x;
                //if(y<ymin) ymin=y;
                //if(y>ymax) ymax=y;
            }

            SoDrawStyle *pstyle = new SoDrawStyle;
            pstyle->pointSize = 2;
            SoMaterial *color = new SoMaterial;
            color->diffuseColor.setValue(0.2,0.8,0.2);

            //draw samples
            psep->addChild(color);
            psep->addChild(points);
            psep->addChild(pstyle);
            psep->addChild(pset);

            _sceneCspace->addChild(psep);


            //draw edges:
            SoSeparator *lsep = new SoSeparator();

            int numOutgoingEdges;

            //std::map< unsigned int, const ob::PlannerDataEdge * > edgeMap;
            std::vector< unsigned int > outgoingVertices;

            for(int i=0;i<pdata->numVertices();i++)
            {
                //numOutgoingEdges = plannerdata->getEdges (i, edgeMap);
                //std::map< unsigned int, const ob::PlannerDataEdge * >::iterator it;
                //for ( it=edgeMap.begin(); it != edgeMap.end(); it++ ){

                numOutgoingEdges = pdata->getEdges (i, outgoingVertices);
                for ( int j=0; j<numOutgoingEdges; j++ ){

                  SoCoordinate3 *edgepoints  = new SoCoordinate3();

                  //edgepoints->point.set1Value((0,points->point[i]);
                  //edgepoints->point.set1Value(1,points->point[(*it).first]);
                  //edgepoints->point.set1Value(1,points->point[outgoingVertices.at(j)]);


                  float x1,y1,x2,y2,z;
                  se3state = pdata->getVertex(i).getState()->as<ob::SE3StateSpace::StateType>();
                  pos = se3state->as<ob::RealVectorStateSpace::StateType>(0);
                  x1=pos->values[0];
                  y1=pos->values[1];
                  z=0.0;
                  edgepoints->point.set1Value(0,x1,y1,z);

                  se3state = pdata->getVertex(outgoingVertices.at(j)).getState()->as<ob::SE3StateSpace::StateType>();
                  pos = se3state->as<ob::RealVectorStateSpace::StateType>(0);
                  x2=pos->values[0];
                  y2=pos->values[1];
                  edgepoints->point.set1Value(1,x2,y2,z);


                  //cout<<"i:"<<i<<" j:"<<outgoingVertices.at(j)<<" weight:"<<plannerdata->getEdgeWeight(i,outgoingVertices.at(j))<<endl;

                  lsep->addChild(edgepoints);

                  SoLineSet *ls = new SoLineSet;
                  ls->numVertices.set1Value(0,2);//two values
                  //cout<<"EDGE "<<(*itC)->first<<" "<<(*itC)->second<<endl;
                  lsep->addChild(ls);
                }
            }
            _sceneCspace->addChild(lsep);

            //draw path:
            if(_solved)
            {
                SoSeparator *pathsep = new SoSeparator();
                std::vector< ob::State * > & pathstates = ss->getSolutionPath().getStates();

                for(int i=0; i<ss->getSolutionPath().getStateCount()-1; i++)
                {
                    SoCoordinate3 *edgepoints  = new SoCoordinate3();
                    se3state = pathstates[i]->as<ob::SE3StateSpace::StateType>();
                    pos = se3state->as<ob::RealVectorStateSpace::StateType>(0);
                    x=pos->values[0];
                    y=pos->values[1];
                    edgepoints->point.set1Value(0,x,y,0);
                    se3state = pathstates[i+1]->as<ob::SE3StateSpace::StateType>();
                    pos = se3state->as<ob::RealVectorStateSpace::StateType>(0);
                    x=pos->values[0];
                    y=pos->values[1];
                    edgepoints->point.set1Value(1,x,y,0);

                    pathsep->addChild(edgepoints);

                    SoLineSet *ls = new SoLineSet;
                    ls->numVertices.set1Value(0,2);//two values
                    SoDrawStyle *lstyle = new SoDrawStyle;
                    lstyle->lineWidth=2;
                    SoMaterial *path_color = new SoMaterial;
                    path_color->diffuseColor.setValue(0.8,0.2,0.2);
                    pathsep->addChild(path_color);
                    pathsep->addChild(lstyle);
                    pathsep->addChild(ls);
                }
                _sceneCspace->addChild(pathsep);
            }


            //draw floor
            SoSeparator *floorsep = new SoSeparator();
            SoCube *cs = new SoCube();
            cs->width = xmax-xmin;
            cs->depth = (xmax-xmin)/50.0;
            cs->height = ymax-ymin;

            SoTransform *cub_transf = new SoTransform;
            SbVec3f centre;
            centre.setValue(xmin+(xmax-xmin)/2,ymin+(ymax-ymin)/2,-cs->depth.getValue());
            cub_transf->translation.setValue(centre);
            cub_transf->recenter(centre);

            SoMaterial *cub_color = new SoMaterial;
            cub_color->diffuseColor.setValue(0.2,0.2,0.2);

            floorsep->addChild(cub_color);
            floorsep->addChild(cub_transf);
            floorsep->addChild(cs);
            _sceneCspace->addChild(floorsep);

            //cout<<"xmin:"<<xmin<<" xmax: "<<xmax<<endl;
            //cout<<"ymin:"<<ymin<<" ymax: "<<ymax<<endl;

            //plannerdata->printGraphviz(outGraphviz);
            //plannerdata->printGraphviz(cout);

    }


    //This routine allows to draw the roadmap or tree for a sigle robot with 2 dof
    void omplPlanner::drawCspaceRn()
    {


        //           pos = pdata->getVertex(i).getState()->as<ob::RealVectorStateSpace::StateType>()


    }




	//! function to find a solution path
        bool omplPlanner::trySolve()
		{

           //Start
            ob::ScopedState<ob::CompoundStateSpace> startompl(space);
            //startompl.random();
            _wkSpace->moveRobotsTo(_init);
            std::vector<RobConf>& initRobotsConf = _init->getMappedConf();

            //Goal
            ob::ScopedState<ob::CompoundStateSpace> goalompl(space);
            //goalompl.random();
            _wkSpace->moveRobotsTo(_goal);
            std::vector<RobConf>& goalRobotsConf = _goal->getMappedConf();

            for(int i=0; i<_wkSpace->robotsCount(); i++)
            {
                int k=0; //counter of subspaces contained in subspace of robot i

                //ob::StateSpacePtr ssRoboti = ((ob::StateSpacePtr) space->as<ob::CompoundStateSpace>()->getSubspace(i)->as<ob::CompoundStateSpace>());
                ob::StateSpacePtr ssRoboti = ((ob::StateSpacePtr) space->as<ob::CompoundStateSpace>()->getSubspace(i));
                string ssRobotiname = ssRoboti->getName();

                //has se3 part
                if(_wkSpace->getRobot(i)->isSE3Enabled())
                {
                    //INIT
                    //get the kautham SE3 configuration
                    SE3Conf c = initRobotsConf.at(i).getSE3();
                    vector<KthReal>& pp = c.getPos();
                    vector<KthReal>& aa = c.getAxisAngle();

                    //set the ompl SE3 configuration
                    //ob::StateSpacePtr ssRobotiSE3 =  ((ob::StateSpacePtr) ssRoboti->as<ob::CompoundStateSpace>()->getSubspace(k)->as<ob::SE3StateSpace>());
                    ob::StateSpacePtr ssRobotiSE3 =  ((ob::StateSpacePtr) ssRoboti->as<ob::CompoundStateSpace>()->getSubspace(k));
                    string ssRobotiSE3name = ssRobotiSE3->getName();

                    ob::ScopedState<ob::SE3StateSpace> cstart(ssRobotiSE3);
                    cstart->setX(pp[0]);
                    cstart->setY(pp[1]);
                    cstart->setZ(pp[2]);
                    cstart->rotation().setAxisAngle(aa[0],aa[1],aa[2],aa[3]);

                    //string kk = startompl[ssRobotiSE3].getSpace()->getName();
                    startompl<<cstart;

//                    std::ostringstream cstartout;
//                    std::ostringstream startomplout;
                    cout<<"cstart:"<<endl;
                    cstart.print();
                    cout<<"startomple:"<<endl;
                    startompl[ssRobotiSE3].print();

                    //GOAL
                    //get the kautham SE3 configuration
                    c = goalRobotsConf.at(i).getSE3();
                    pp = c.getPos();
                    aa = c.getAxisAngle();

                    //set the ompl SE3 configuration
                    ob::ScopedState<ob::SE3StateSpace> cgoal(ssRobotiSE3);
                    cgoal->setX(pp[0]);
                    cgoal->setY(pp[1]);
                    cgoal->setZ(pp[2]);
                    cgoal->rotation().setAxisAngle(aa[0],aa[1],aa[2],aa[3]);
                    goalompl<< cgoal;
                    k++;

                }

                //has Rn part
                if(_wkSpace->getRobot(i)->getNumJoints()>1)
                {
                    //INIT
                    //get the kautham Rn configuration
                    RnConf r = initRobotsConf.at(i).getRn();

                    //set the omple Rn configuration
                    //ob::StateSpacePtr ssRobotiRn =  ((ob::StateSpacePtr) ssRoboti->as<ob::CompoundStateSpace>()->getSubspace(k)->as<ob::RealVectorStateSpace>());
                    ob::StateSpacePtr ssRobotiRn =  ((ob::StateSpacePtr) ssRoboti->as<ob::CompoundStateSpace>()->getSubspace(k));
                    ob::ScopedState<ob::RealVectorStateSpace> rstart(ssRobotiRn);

                    for(int j=1; j<_wkSpace->getRobot(i)->getNumJoints();j++)
                        rstart[j] = r.getCoordinate(j);
                    startompl << rstart;


                    //GOAL
                    //get the kautham Rn configuration
                    r = goalRobotsConf.at(i).getRn();

                    //set the omple Rn configuration
                    ob::ScopedState<ob::RealVectorStateSpace> rgoal(ssRobotiRn);
                    for(int j=1; j<_wkSpace->getRobot(i)->getNumJoints();j++)
                        rgoal[j] = r.getCoordinate(j);
                    startompl << rgoal;
                    k++;

                }
            }


            // set the start and goal states
            ss->setStartAndGoalStates(startompl, goalompl);

            // attempt to solve the problem within _planningTime seconds of planning time
            ss->clear();//to remove previous solutions, if any
            ss->getPlanner()->clear();
            ob::PlannerStatus solved = ss->solve(_planningTime);
            ss->print();

            if (solved)
            {
                    std::cout << "Found solution:" << std::endl;
                    // print the path to screen
                    ss->simplifySolution();
                    ss->getSolutionPath().print(std::cout);
                    std::vector< ob::State * > & pathstates = ss->getSolutionPath().getStates();


                    ob::ScopedState<ob::CompoundStateSpace> pathscopedstate(space);

                    Sample *smp=new Sample(_wkSpace->getDimension());

                    _path.clear();
                    clearSimulationPath();

                    //load the kautham _path variable from the ompl solution
                    for(int j=0;j<ss->getSolutionPath().getStateCount();j++){
                        vector<RobConf> rc;
                        rc.resize(_wkSpace->robotsCount());
                        //ob::CompoundStateSpace::StateType *p;

                        //p = pathstates[j]->as<ob::CompoundStateSpace::StateType>();

                        pathscopedstate = (*pathstates[j]->as<ob::CompoundStateSpace::StateType>());

                        int k=0;
                        for(int i=0; i<_wkSpace->robotsCount(); i++)
                        {
                            RobConf *rcj = new RobConf;

                            ob::StateSpacePtr ssRoboti = ((ob::StateSpacePtr) space->as<ob::CompoundStateSpace>()->getSubspace(i));
                            ob::CompoundStateSpace::StateType *pi = pathscopedstate[ssRoboti].get()->as<ob::CompoundStateSpace::StateType>();

                             int k=0;
                             if(_wkSpace->getRobot(i)->isSE3Enabled())
                             {
                                 ob::StateSpacePtr ssRobotiSE3 =  ((ob::StateSpacePtr) ssRoboti->as<ob::CompoundStateSpace>()->getSubspace(k));


                                 //ob::SE3StateSpace::StateType *pse3 = pathscopedstate[ssRobotiSE3].get()->as<ob::SE3StateSpace::StateType>();
                                 //ob::SE3StateSpace::StateType *pse3 = (*(*pathstates[j])[i])[k];
                                 //ob::SE3StateSpace::StateType *pse3 = p->as<ob::SE3StateSpace::StateType>(k++);

                                 ob::ScopedState<ob::SE3StateSpace> pathscopedstatese3(ssRobotiSE3);
                                 pathscopedstate >> pathscopedstatese3;
                                 //ob::SE3StateSpace::StateType *pse3 = pathscopedstatese3.get();
                                 double x = pathscopedstatese3->getX();
                                 double y = pathscopedstatese3->getY();
                                 double z = pathscopedstatese3->getZ();
                                 vector<KthReal> quaternioncoords;
                                 quaternioncoords.resize(4);
                                 quaternioncoords[0] = pathscopedstatese3->rotation().x;
                                 quaternioncoords[1] = pathscopedstatese3->rotation().y;
                                 quaternioncoords[2] = pathscopedstatese3->rotation().z;
                                 quaternioncoords[3] = pathscopedstatese3->rotation().w;
                                 SE3Conf se3;
                                 se3.setCoordinates(quaternioncoords);
                                 rcj->setSE3(se3);
                                 k++;
                             }
                             if(_wkSpace->getRobot(i)->getNumJoints()>1)
                             {
                                 ob::StateSpacePtr ssRobotiRn =  ((ob::StateSpacePtr) ssRoboti->as<ob::CompoundStateSpace>()->getSubspace(k));

                                 ob::RealVectorStateSpace::StateType *prn = pathscopedstate[ssRobotiRn].get()->as<ob::RealVectorStateSpace::StateType>();

                                 //ob::RealVectorStateSpace::StateType *prn = p->as<ob::RealVectorStateSpace::StateType>(k++);
                                 rcj->setRn((vector<KthReal>&) prn);
                                 k++;//dummy
                             }
                             rc.push_back(*rcj);
                        }
                        smp->setMappedConf(rc);


                        _path.push_back(smp);
                        smp=new Sample(_wkSpace->getDimension());
                   }

                    _solved = true;
                    drawCspace();
                    return _solved;
                }
                else{
                    std::cout << "No solution found" << std::endl;
                    _solved = false;
                    drawCspace();
                    return _solved;
            }
		}
    }
}

#endif // KAUTHAM_USE_OMPL


