/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include "problem.h"



#include <string>
#include <fstream>
#include <iostream>
#include <boost/algorithm/string.hpp>

//solving convertions problems
#include <locale.h>


#if defined(KAUTHAM_USE_IOC)
#include <libioc/myplanner.h>
#include <libioc/prmplanner.h>
#include <libioc/prmhandplannerICRA.h>
#include <libioc/prmAUROhandarmplanner.h>
#include <libioc/prmPCAhandarmplanner.h>
#include <libioc/prmrobothandconstplannerICRA.h>
#include <libioc/prmhandplannerIROS.h>
#include <libioc/myprmplanner.h>
#include <libioc/mygridplanner.h>
#include <libioc/NF1planner.h>
#include <libioc/HFplanner.h>
#endif

#if defined(KAUTHAM_USE_OMPL)
#include <libompl/omplPRMplanner.h>
#include <libompl/omplRRTplanner.h>
#include <libompl/omplRRTStarplanner.h>
#include <libompl/omplTRRTplanner.h>
#include <libompl/omplpRRTplanner.h>
#include <libompl/omplLazyRRTplanner.h>
#include <libompl/omplcRRTplanner.h>
#include <libompl/omplcRRTcarplanner.h>
#include <libompl/omplcRRTf16planner.h>
#include <libompl/omplRRTConnectplanner.h>
#include <libompl/omplESTplanner.h>
#include <libompl/omplSBLplanner.h>
#include <libompl/omplKPIECEplanner.h>
#include <libompl/omplKPIECEplanner.h>
#endif


#if defined(KAUTHAM_USE_GUIBRO)
#include <libguibro/consbronchoscopykin.h>
#include <libguibro/guibrogridplanner.h>
#endif // KAUTHAM_USE_GUIBRO

#if !defined(M_PI)
#define M_PI 3.1415926535897932384626433832795
#endif


using namespace std;
using namespace pugi;

namespace Kautham {



  const KthReal Problem::_toRad = (KthReal)(M_PI/180.0);
  Problem::Problem() {
        _wspace = NULL;
    _planner = NULL;
    _sampler = NULL;
    _cspace = new SampleSet();
    _cspace->clear();
    _currentControls.clear();
	}

  Problem::~Problem(){
      delete _cspace; //must be deleted first, if not the program crashes...
    delete _wspace;
    delete _planner;
    delete _sampler;
  }


  // This is the new implementation trying to avoid the old strucparse and ProbStruc.
  void Problem::createWSpace(xml_document *doc){
    if(_wspace != NULL ) delete _wspace;
    _wspace = new IVWorkSpace();

    char *old = setlocale (LC_NUMERIC, "C");
    // Setup the examples directory.
    string dir = _filePath;
    dir.erase(dir.find_last_of("/") + 1 );

    KthReal pob[3], oob[4];
    Obstacle *obs;
    Robot *rob;
    bool flagCol;

    xml_node tmpNode = doc->child("Problem");
    string name = "";
    for(xml_node_iterator it = tmpNode.begin(); it != tmpNode.end(); ++it){ // Processing each child
      name = it->name();
      // it can be an Scene or an obstacle.
      if(name == "Scene" ){
        // It can be either a mobile obstacle (Robot) or a fixed obstacle.
        fstream fin;
        string obsFile = dir + (*it).attribute("scene").value();
        fin.open(obsFile.c_str(),ios::in);
        if( fin.is_open() ){ // The file already exists.
          fin.close();
          string::size_type loc = obsFile.find( ".rob", 0 );
          if( loc != string::npos ) { // It means that the obstacle is a robot.
#ifndef KAUTHAM_COLLISION_PQP
            rob = new Robot( dir + (*it).attribute("scene").value(),
                        (KthReal)(*it).attribute("scale").as_double(),INVENTOR);
#else
            rob = new Robot( dir + (*it).attribute("scene").value(),
                        (KthReal)(*it).attribute("scale").as_double(),IVPQP);
#endif
            // Setup the limits of the moveable base
            for(xml_node_iterator itL = (*it).begin(); itL != (*it).end(); ++itL){
              name = (*itL).name();
              if( name == "Limits" ){
                name = (*itL).attribute("name").value();
                if( name == "X")
                  rob->setLimits(0, (KthReal)(*itL).attribute("min").as_double(),
                                 (KthReal)(*itL).attribute("max").as_double());
                else if( name == "Y")
                  rob->setLimits(1, (KthReal)(*itL).attribute("min").as_double(),
                                 (KthReal)(*itL).attribute("max").as_double());
                else if( name == "Z")
                  rob->setLimits(2, (KthReal)(*itL).attribute("min").as_double(),
                                 (KthReal)(*itL).attribute("max").as_double());
                else if( name == "WX")
                  rob->setLimits(3, (KthReal)(*itL).attribute("min").as_double(),
                                 (KthReal)(*itL).attribute("max").as_double());
                else if( name == "WY")
                  rob->setLimits(4, (KthReal)(*itL).attribute("min").as_double(),
                                 (KthReal)(*itL).attribute("max").as_double());
                else if( name == "WZ")
                  rob->setLimits(5, (KthReal)(*itL).attribute("min").as_double(),
                                 (KthReal)(*itL).attribute("max").as_double());
                else if( name == "TH")
                  rob->setLimits(6, (KthReal)(*itL).attribute("min").as_double() * _toRad,
                                 (KthReal)(*itL).attribute("max").as_double() * _toRad);
              }
              if( name == "Home" ){
              // If robot hasn't a home, it will be assumed in the origin.
                SE3Conf tmpC;
                vector<KthReal> cords(7);
                cords[0] = (KthReal)(*itL).attribute("X").as_double();
                cords[1] = (KthReal)(*itL).attribute("Y").as_double();
                cords[2] = (KthReal)(*itL).attribute("Z").as_double();
                cords[3] = (KthReal)(*itL).attribute("WX").as_double();
                cords[4] = (KthReal)(*itL).attribute("WY").as_double();
                cords[5] = (KthReal)(*itL).attribute("WZ").as_double();
                cords[6] = (KthReal)(*itL).attribute("TH").as_double() * _toRad;

                // Here is needed to convert from axis-angle to
                // quaternion internal represtantation.
                SE3Conf::fromAxisToQuaternion(cords);

                tmpC.setCoordinates(cords);

                rob->setHomePos(&tmpC);
              }
            }

            _wspace->addMobileObstacle(rob);
          } else {
              loc = obsFile.find( ".urdf", 0 );
              if( loc != string::npos ) {
                  // It can be a mobile obstacle (Robot) or a fixed obstacle.
                  if ((*it).child("Limits") || (*it).child("Home")) {
                      // It means that the obstacle is a robot.
#ifndef KAUTHAM_COLLISION_PQP
                      rob = new Robot( dir + (*it).attribute("scene").value(),
                                       (KthReal)(*it).attribute("scale").as_double(),INVENTOR);
#else
                      rob = new Robot( dir + (*it).attribute("scene").value(),
                                       (KthReal)(*it).attribute("scale").as_double(),IVPQP);
#endif
                      // Setup the limits of the moveable base
                      for(xml_node_iterator itL = (*it).begin(); itL != (*it).end(); ++itL){
                          name = (*itL).name();
                          if( name == "Limits" ){
                              name = (*itL).attribute("name").value();
                              if( name == "X")
                                  rob->setLimits(0, (KthReal)(*itL).attribute("min").as_double(),
                                                 (KthReal)(*itL).attribute("max").as_double());
                              else if( name == "Y")
                                  rob->setLimits(1, (KthReal)(*itL).attribute("min").as_double(),
                                                 (KthReal)(*itL).attribute("max").as_double());
                              else if( name == "Z")
                                  rob->setLimits(2, (KthReal)(*itL).attribute("min").as_double(),
                                                 (KthReal)(*itL).attribute("max").as_double());
                              else if( name == "WX")
                                  rob->setLimits(3, (KthReal)(*itL).attribute("min").as_double(),
                                                 (KthReal)(*itL).attribute("max").as_double());
                              else if( name == "WY")
                                  rob->setLimits(4, (KthReal)(*itL).attribute("min").as_double(),
                                                 (KthReal)(*itL).attribute("max").as_double());
                              else if( name == "WZ")
                                  rob->setLimits(5, (KthReal)(*itL).attribute("min").as_double(),
                                                 (KthReal)(*itL).attribute("max").as_double());
                              else if( name == "TH")
                                  rob->setLimits(6, (KthReal)(*itL).attribute("min").as_double() * _toRad,
                                                 (KthReal)(*itL).attribute("max").as_double() * _toRad);
                          }
                          if( name == "Home" ){
                              // If robot hasn't a home, it will be assumed in the origin.
                              SE3Conf tmpC;
                              vector<KthReal> cords(7);
                              cords[0] = (KthReal)(*itL).attribute("X").as_double();
                              cords[1] = (KthReal)(*itL).attribute("Y").as_double();
                              cords[2] = (KthReal)(*itL).attribute("Z").as_double();
                              cords[3] = (KthReal)(*itL).attribute("WX").as_double();
                              cords[4] = (KthReal)(*itL).attribute("WY").as_double();
                              cords[5] = (KthReal)(*itL).attribute("WZ").as_double();
                              cords[6] = (KthReal)(*itL).attribute("TH").as_double() * _toRad;

                              // Here is needed to convert from axis-angle to
                              // quaternion internal represtantation.
                              SE3Conf::fromAxisToQuaternion(cords);

                              tmpC.setCoordinates(cords);

                              rob->setHomePos(&tmpC);
                          }
                      }

                      _wspace->addMobileObstacle(rob);
                  } else {
                      // It means that it is a fixed object.
                      if((*it).child("Collision"))
                          flagCol = (*it).child("Collision").attribute("Enable").as_bool();
                      else
                          flagCol = true;

                      xml_node locObs = (*it).child("Location");
                      pob[0] = (KthReal)locObs.attribute("X").as_double();
                      pob[1] = (KthReal)locObs.attribute("Y").as_double();
                      pob[2] = (KthReal)locObs.attribute("Z").as_double();
                      oob[0] = (KthReal)locObs.attribute("WX").as_double();
                      oob[1] = (KthReal)locObs.attribute("WY").as_double();
                      oob[2] = (KthReal)locObs.attribute("WZ").as_double();
                      oob[3] = (KthReal)locObs.attribute("TH").as_double() * _toRad;

                      // Changing between axis angle to quaternion.
                      SE3Conf::fromAxisToQuaternion(oob);

#ifndef KAUTHAM_COLLISION_PQP
                      obs = new Obstacle(dir + (*it).attribute("scene").value(), pob, oob,
                                         (KthReal)(*it).attribute("scale").as_double(), INVENTOR, flagCol);
#else
                      obs = new Obstacle( dir + (*it).attribute("scene").value(), pob, oob,
                                          (KthReal)(*it).attribute("scale").as_double(), IVPQP, flagCol);
#endif
                      _wspace->addObstacle(obs);
                  }
              } else {
                  //  It is a fixed object
                  if((*it).child("Collision"))
                      flagCol = (*it).child("Collision").attribute("Enable").as_bool();
                  else
                      flagCol = true;

                  xml_node locObs = (*it).child("Location");
                  pob[0] = (KthReal)locObs.attribute("X").as_double();
                  pob[1] = (KthReal)locObs.attribute("Y").as_double();
                  pob[2] = (KthReal)locObs.attribute("Z").as_double();
                  oob[0] = (KthReal)locObs.attribute("WX").as_double();
                  oob[1] = (KthReal)locObs.attribute("WY").as_double();
                  oob[2] = (KthReal)locObs.attribute("WZ").as_double();
                  oob[3] = (KthReal)locObs.attribute("TH").as_double() * _toRad;

                  // Changing between axis angle to quaternion.
                  SE3Conf::fromAxisToQuaternion(oob);

#ifndef KAUTHAM_COLLISION_PQP
                  obs = new Obstacle(dir + (*it).attribute("scene").value(), pob, oob,
                                     (KthReal)(*it).attribute("scale").as_double(), INVENTOR, flagCol);
#else
                  obs = new Obstacle( dir + (*it).attribute("scene").value(), pob, oob,
                                      (KthReal)(*it).attribute("scale").as_double(), IVPQP, flagCol);
#endif
                  _wspace->addObstacle(obs);
              }
          }
        } else {
            cout << "The obstacle " << (*it).attribute("scene").value() <<" is improperly configured.";
        }
      }
      // it can be a Robot.
      if(name == "Robot" ){
#ifndef KAUTHAM_COLLISION_PQP
        rob = new Robot( dir + (*it).attribute("robot").value(),
                        (KthReal)(*it).attribute("scale").as_double(),INVENTOR);
#else
        rob = new Robot( dir + (*it).attribute("robot").value(),
                        (KthReal)(*it).attribute("scale").as_double(),IVPQP);
#endif

        // Setup the Inverse Kinematic if it has one.
        if((*it).child("InvKinematic")){
          name = (*it).child("InvKinematic").attribute("name").value();
          if( name == "RR2D" )
            rob->setInverseKinematic( Kautham::RR2D );
          else if( name == "TX90")
            rob->setInverseKinematic( Kautham::TX90 );
          else if( name == "HAND")
            rob->setInverseKinematic( Kautham::HAND );
          else if( name == "TX90HAND")
            rob->setInverseKinematic( Kautham::TX90HAND );
          else if( name == "UR5")
            rob->setInverseKinematic( Kautham::UR5 );
          else
            rob->setInverseKinematic(Kautham::UNIMPLEMENTED);
        }else
          rob->setInverseKinematic(Kautham::UNIMPLEMENTED);

        // Setup the Constrained Kinematic if it has one.
        if((*it).child("ConstrainedKinematic")){
          name = (*it).child("ConstrainedKinematic").attribute("name").value();

          rob->setConstrainedKinematic( Kautham::UNCONSTRAINED );
#if defined(KAUTHAM_USE_GUIBRO)
		  if( name == "BRONCHOSCOPY" ){
            rob->setConstrainedKinematic( Kautham::BRONCHOSCOPY );
            double amin = (*it).child("ConstrainedKinematic").attribute("amin").as_double();
            double amax = (*it).child("ConstrainedKinematic").attribute("amax").as_double();
            double bmin = (*it).child("ConstrainedKinematic").attribute("bmin").as_double();
            double bmax = (*it).child("ConstrainedKinematic").attribute("bmax").as_double();
            ((GUIBRO::ConsBronchoscopyKin*)rob->getCkine())->setAngleLimits(bmin*M_PI/180.0, bmax*M_PI/180.0, amin*M_PI/180.0, amax*M_PI/180.0);
		  }
          else
            rob->setConstrainedKinematic( Kautham::UNCONSTRAINED );
#endif
        }else{
          rob->setConstrainedKinematic( Kautham::UNCONSTRAINED );
        }

        // Setup the limits of the moveable base
        for(xml_node_iterator itL = (*it).begin(); itL != (*it).end(); ++itL){
          name = (*itL).name();
          if( name == "Limits" ){
            name = (*itL).attribute("name").value();
            if( name == "X")
              rob->setLimits(0, (KthReal)(*itL).attribute("min").as_double(),
                             (KthReal)(*itL).attribute("max").as_double());
            else if( name == "Y")
              rob->setLimits(1, (KthReal)(*itL).attribute("min").as_double(),
                             (KthReal)(*itL).attribute("max").as_double());
            else if( name == "Z")
              rob->setLimits(2, (KthReal)(*itL).attribute("min").as_double(),
                             (KthReal)(*itL).attribute("max").as_double());
            else if( name == "WX")
              rob->setLimits(3, (KthReal)(*itL).attribute("min").as_double(),
                             (KthReal)(*itL).attribute("max").as_double());
            else if( name == "WY")
              rob->setLimits(4, (KthReal)(*itL).attribute("min").as_double(),
                             (KthReal)(*itL).attribute("max").as_double());
            else if( name == "WZ")
              rob->setLimits(5, (KthReal)(*itL).attribute("min").as_double(),
                             (KthReal)(*itL).attribute("max").as_double());
            else if( name == "TH")
              rob->setLimits(6, (KthReal)(*itL).attribute("min").as_double() * _toRad,
                             (KthReal)(*itL).attribute("max").as_double() * _toRad);
          }
          if( name == "Home" ){
          // If robot hasn't a home, it will be assumed in the origin.
            SE3Conf tmpC;
            vector<KthReal> cords(7);
            cords[0] = (KthReal)(*itL).attribute("X").as_double();
            cords[1] = (KthReal)(*itL).attribute("Y").as_double();
            cords[2] = (KthReal)(*itL).attribute("Z").as_double();
            cords[3] = (KthReal)(*itL).attribute("WX").as_double();
            cords[4] = (KthReal)(*itL).attribute("WY").as_double();
            cords[5] = (KthReal)(*itL).attribute("WZ").as_double();
            cords[6] = (KthReal)(*itL).attribute("TH").as_double() * _toRad;

            // Here is needed to convert from axis-angle to
            // quaternion internal represtantation.
            SE3Conf::fromAxisToQuaternion(cords);

            tmpC.setCoordinates(cords);

            //cout << tmpC.print();

            rob->setHomePos(&tmpC);
          }
        }

        _wspace->addRobot(rob);
      }

      //  it can be a distance map file
      if(name == "DistanceMap" ){
			  _wspace->addDistanceMapFile(dir + (*it).attribute("distanceMap").value());
	    }
      if(name == "DimensionsFile" ){
			  _wspace->addDimensionsFile(dir + (*it).attribute("filename").value());
			  _wspace->addDirCase(dir);
	    }

    }// closing for(xml_node_iterator it = tmpNode.begin(); it != tmpNode.end(); ++it){ // Processing each child

    _currentControls.clear();
    _currentControls.resize(_wspace->getDimension());

    for(int i = 0; i<_wspace->getDimension(); i++)
      _currentControls[i] = (KthReal)0.0;

    setlocale (LC_NUMERIC, old);
  }

	WorkSpace* Problem::wSpace(){
		return _wspace;
	}

    SampleSet* Problem::cSpace(){
        return _cspace;
    }

  void Problem::setHomeConf(Robot* rob, HASH_S_K* param){
    Conf* tmpC = new SE3Conf();
    vector<KthReal> cords(7);
    string search[]={"X", "Y", "Z", "WX", "WY", "WZ", "TH"};
    HASH_S_K::iterator it;

    for(int i = 0; i < 7; i++){
      it = param->find(search[i]);
      if( it != param->end())
        cords[i]= it->second;
      else
        cords[i] = 0.0;
    }

    // Here is needed to convert from axis-angle to
    // quaternion internal represtantation.
    SE3Conf::fromAxisToQuaternion(cords);

    tmpC->setCoordinates(cords);
    rob->setHomePos(tmpC);
    delete tmpC;
    cords.clear();

    if(rob->getNumJoints() > 0){
      cords.resize(rob->getNumJoints());
      tmpC = new RnConf(rob->getNumJoints());
      for(int i = 0; i < tmpC->getDim(); i++){
        it = param->find(rob->getLink(i+1)->getName());
        if( it != param->end())
          cords[i]= it->second;
        else
          cords[i] = 0.0;
      }

      tmpC->setCoordinates(cords);
      rob->setHomePos(tmpC);
      delete tmpC;
    }
  }



  bool Problem::createPlanner( string name, ompl::geometric::SimpleSetup *ssptr ){
    if(_planner != NULL )
      delete _planner;

    Sample *sinit=NULL;
    Sample *sgoal=NULL;
    if(_cspace->getSize()>=2)
    {
        sinit=_cspace->getSampleAt(0);
        sgoal=_cspace->getSampleAt(1);
    }

    if(name == "dummy") //Dummy if to start.
        cout<<"planer name is dummy?"<<endl;

#if defined(KAUTHAM_USE_IOC)
    else if(name == "PRM")
      _planner = new IOC::PRMPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _sampler, _wspace);

    else if(name == "PRM Hand IROS")
      _planner = new IOC::PRMHandPlannerIROS(CONTROLSPACE, sinit, sgoal,
                                       _cspace, _sampler, _wspace, 5, (KthReal)0.001 );
    else if(name == "PRM Hand ICRA")
      _planner = new IOC::PRMHandPlannerICRA(CONTROLSPACE, sinit, sgoal,
                                       _cspace, _sampler, _wspace, 100, 5, (KthReal)0.010, 5);

     else if(name == "PRMAURO HandArm")
      _planner = new IOC::PRMAUROHandArmPlanner(CONTROLSPACE, sinit, sgoal, _cspace,
                                             _sampler, _wspace, 10, (KthReal)0.0010, 10);

     else if(name == "PRM RobotHand-Const ICRA")
      _planner = new IOC::PRMRobotHandConstPlannerICRA(CONTROLSPACE, sinit, sgoal, _cspace,
                                             _sampler, _wspace, 3, (KthReal)50.0);
   	 else if(name == "MyPlanner")
      _planner = new IOC::MyPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _sampler, _wspace);

	 else if(name == "MyPRMPlanner")
      _planner = new IOC::MyPRMPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _sampler, _wspace);

	  else if(name == "MyGridPlanner")
      _planner = new IOC::MyGridPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _sampler, _wspace);

	   else if(name == "NF1Planner")
      _planner = new IOC::NF1Planner(CONTROLSPACE, sinit, sgoal, _cspace, _sampler, _wspace);

	   else if(name == "HFPlanner")
      _planner = new IOC::HFPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _sampler, _wspace);

#if defined(KAUTHAM_USE_ARMADILLO)

    else if(name == "PRMPCA HandArm")
      _planner = new IOC::PRMPCAHandArmPlanner(CONTROLSPACE, sinit, sgoal, _cspace,
                                             _sampler, _wspace, 10,0, (KthReal)0.0010, 10,0.0,0.0);
#endif
#endif

#if defined(KAUTHAM_USE_GUIBRO)
    else if(name == "GUIBROgrid")
      _planner = new GUIBRO::GUIBROgridPlanner(CONTROLSPACE, NULL, NULL, _cspace, _sampler, _wspace);
#endif

#if defined(KAUTHAM_USE_OMPL)

    else if(name == "omplDefault")
      _planner = new omplplanner::omplPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _wspace, ssptr);

    else if(name == "omplPRM")
      _planner = new omplplanner::omplPRMPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _wspace, ssptr);

    else if(name == "omplRRT")
      _planner = new omplplanner::omplRRTPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _wspace, ssptr);

    else if(name == "omplRRTStar")
      _planner = new omplplanner::omplRRTStarPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _wspace, ssptr);

    else if(name == "omplTRRT")
      _planner = new omplplanner::omplTRRTPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _wspace, ssptr);

    else if(name == "omplpRRT")
      _planner = new omplplanner::omplpRRTPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _wspace, ssptr);

    else if(name == "omplLazyRRT")
      _planner = new omplplanner::omplLazyRRTPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _wspace, ssptr);

    else if(name == "omplRRTConnect")
      _planner = new omplplanner::omplRRTConnectPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _wspace, ssptr);

    else if(name == "omplEST")
      _planner = new omplplanner::omplESTPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _wspace, ssptr);

    else if(name == "omplSBL")
      _planner = new omplplanner::omplSBLPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _wspace, ssptr);

    else if(name == "omplKPIECE")
      _planner = new omplplanner::omplKPIECEPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _wspace, ssptr);

    else if(name == "omplBKPIECE")
      _planner = new omplplanner::omplKPIECEPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _wspace, ssptr);

    else if(name == "omplcRRT")
      _planner = new omplcplanner::omplcRRTPlanner(CONTROLSPACE, sinit, sgoal, _cspace,_wspace);

    else if(name == "omplcRRTf16")
      _planner = new omplcplanner::omplcRRTf16Planner(CONTROLSPACE, sinit, sgoal, _cspace, _wspace);

    else if(name == "omplcRRTcar")
      _planner = new omplcplanner::omplcRRTcarPlanner(CONTROLSPACE, sinit, sgoal, _cspace, _wspace);

    else
        cout<<"Planner "<< name <<" is unknow or not loaded (check the CMakeFiles.txt options)" << endl;

#endif

    if(_planner != NULL)
      return true;
    else
      return false;
  }


  bool Problem::createPlannerFromFile(xml_document *doc, ompl::geometric::SimpleSetup *ssptr){
    if(_planner == NULL ){
        //Create the planner and set the parameters
        xml_node planNode = doc->child("Problem").child("Planner").child("Parameters");
        string name = planNode.child("Name").child_value();

        if( name != ""){
          if( createPlanner(name,ssptr) ){
            xml_node::iterator it;
            for(it = planNode.begin(); it != planNode.end(); ++it){
              name = it->name();
              try{
                if( name == "Parameter" ){
                  name = it->attribute("name").value();
                  _planner->setParametersFromString( name.append("|").append(it->child_value()));
                }
              }catch(...){
                std::cout << "Current planner doesn't have at least one of the parameters"
                  << " found in the file (" << name << ")." << std::endl;
                //return false; //changed, let it continue -
              }
            }
            return true;
          }
        }
    }
    return false;
  }


  bool Problem::createCSpaceFromFile(xml_document *doc){
    if( createCSpace() ){
        xml_node queryNode = doc->child("Problem").child("Planner").child("Queries");
        xml_node::iterator it;
        int i = 0;
        vector<string> tokens;
        string sentence = "";
        Sample* tmpSampPointer = NULL;
        unsigned int dim = _wspace->getDimension();
        vector<KthReal> coordsVec( dim );
        for( it = queryNode.begin(); it != queryNode.end(); ++it ){
          xml_node sampNode = it->child("Init");
          if( dim == sampNode.attribute("dim").as_int() ){
            sentence = sampNode.child_value();

            boost::split(tokens, sentence, boost::is_any_of("| "));
            if(tokens.size() != dim){
              std::cout << "Dimension of a samples doesn't correspond with the problem's dimension.\n";
              break;
            }

            tmpSampPointer = new Sample(dim);
            for(char i=0; i<dim; i++)
              coordsVec[i] = (KthReal)atof(tokens[i].c_str());

            tmpSampPointer->setCoords(coordsVec);
            // Adding the mapping to configuration space with the collision test.
            if(_wspace->collisionCheck(tmpSampPointer) == true)
                cout<<"Init sample is in collision"<<endl;
            _cspace->add(tmpSampPointer);

          }else{
            cout << "Dimension of a samples doesn't correspond with the problem's dimension.\n";
            break;
          }

          sampNode = it->child("Goal");
          if( dim == sampNode.attribute("dim").as_int() ){
            sentence = sampNode.child_value();

            boost::split(tokens, sentence, boost::is_any_of("| "));
            if(tokens.size() != dim){
              std::cout << "Dimension of a samples doesn't correspond with the problem's dimension.\n";
              break;
            }

            tmpSampPointer = new Sample(dim);
            for(char i=0; i<dim; i++)
              coordsVec[i] = (KthReal)atof(tokens[i].c_str());

            tmpSampPointer->setCoords(coordsVec);
            // Adding the mapping to configuration space with the collision test.
            if(_wspace->collisionCheck(tmpSampPointer)==true)
                cout<<"Goal sample is in collision"<<endl;
            _cspace->add(tmpSampPointer);

          }else{
            cout << "Sample doesn't have the right dimension.\n";
            break;
          }
        }
        if( _cspace->getSize() >= 2 ){
          _cspace->getSampleAt(0)->addNeigh(1);
          _cspace->getSampleAt(1)->addNeigh(0);
          return true;
        }
    }
    return false;
  }

  bool Problem::createCSpace(){
    try{
      if(_cspace == NULL) _cspace = new SampleSet();
      if(_sampler == NULL) _sampler = new RandomSampler(_wspace->getDimension());
      _cspace->clear();
      return true;
    }catch(...){
      return false;
    }
  }

  bool Problem::setCurrentControls(vector<KthReal> &val, int offset){
    try{
      for(unsigned int i=0; i < val.size(); i++)
        _currentControls[i+offset] = (KthReal)val[i];
      return true;
    }catch(...){
      return false;
    }

  }



  bool Problem::setupFromFile(ifstream* xml_inputfile, string modelsfolder)
  {
      _filePath = modelsfolder.c_str();
      xml_document *doc = new xml_document;
      xml_parse_result result = doc->load( *xml_inputfile );
      if(result)
            return setupFromFile(doc);
  }



  bool Problem::setupFromFile(string xml_doc)
  {
      _filePath = xml_doc;
      xml_document *doc = new xml_document;
      xml_parse_result result = doc->load_file( xml_doc.c_str() );
      if(result)
            return setupFromFile(doc);
  }

  bool Problem::setupFromFile(xml_document *doc)
  {
      createWSpace( doc );
      if( createCSpaceFromFile( doc ) == false)
      {
          return false;
      }
      if( createPlannerFromFile( doc ) == false)
      {
          return false;
      }
      return true;
  }

  bool Problem::saveToFile(string file_path){
    if( file_path == "" )  file_path = _filePath;
    if( _filePath != file_path ){ // If save as
      ifstream initialFile(_filePath.c_str(), ios::in|ios::binary);
	    ofstream outputFile(file_path.c_str(), ios::out|ios::binary);

	    //As long as both the input and output files are open...
	    if(initialFile.is_open() && outputFile.is_open()){
        outputFile << initialFile.rdbuf() ;
	    }else           //there were any problems with the copying process
        return false;

	    initialFile.close();
	    outputFile.close();
    }

    xml_document doc;
    xml_parse_result result = doc.load_file( file_path.c_str() );
    if( !result ) return false;

    if( _planner == NULL ) return false;
    if( _planner->initSamp() == NULL || _planner->goalSamp() == NULL )
      return false;

    if( doc.child("Problem").child("Planner") )
      doc.child("Problem").remove_child("Planner");

    xml_node planNode = doc.child("Problem").append_child();
    planNode.set_name("Planner");
    xml_node paramNode = planNode.append_child();
    paramNode.set_name("Parameters");
    xml_node planname = paramNode.append_child();
    planname.set_name("Name");
    planname.append_child(node_pcdata).set_value(_planner->getIDName().c_str());



    // Adding the parameters
    string param = _planner->getParametersAsString();
    vector<string> tokens;
    boost::split(tokens, param, boost::is_any_of("|"));

    for(int i=0; i<tokens.size(); i=i+2){
      xml_node paramItem = paramNode.append_child();
      paramItem.set_name("Parameter");
      paramItem.append_attribute("name") = tokens[i].c_str();
      paramItem.append_child(node_pcdata).set_value(tokens[i+1].c_str());
    }

    // Adding the Query information

    xml_node queryNode = planNode.append_child();
    queryNode.set_name("Queries");

    xml_node queryItem = queryNode.append_child();
    queryItem.set_name("Query");
    xml_node initNode = queryItem.append_child();
    initNode.set_name( "Init" );
    initNode.append_attribute("dim") = _wspace->getDimension();
    initNode.append_child(node_pcdata).set_value( _planner->initSamp()->print(true).c_str() );
    xml_node goalNode = queryItem.append_child();
    goalNode.set_name( "Goal" );
    goalNode.append_attribute("dim") = _wspace->getDimension();
    goalNode.append_child(node_pcdata).set_value( _planner->goalSamp()->print(true).c_str() );

    return doc.save_file(file_path.c_str());
  }

  bool Problem::inheritSolution(){
    if(_planner->isSolved()){
      _wspace->inheritSolution(*(_planner->getSimulationPath()));
      return true;
    }
    return false;
  }
}

