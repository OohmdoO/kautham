/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 
#include "devicewidget.h"

namespace libGUI{
  DeviceWidget::DeviceWidget(Device* dev/*, unsigned int period*/):KauthamWidget(dev){
    _device = dev;

    // Tailoring the KauthamWidget base class to cover the device performance.
    if(_device->getParametersAsString() == "")
      hideTable();

    if(_device->getIncomingParametersAsString() != "" ){
      _incomingTable = new QTableWidget(this);
      _incomingTable->setObjectName(QString::fromUtf8("incomingTable"));
      QSizePolicy sizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
      sizePolicy.setHorizontalStretch(0);
      sizePolicy.setVerticalStretch(0);
      sizePolicy.setHeightForWidth(_incomingTable->sizePolicy().hasHeightForWidth());
      _incomingTable->setSizePolicy(sizePolicy);
      _incomingTable->setMinimumSize(QSize(200, 200));
      _incomingTable->setMaximumSize(QSize(250, 16777215));
      vboxLayout->addWidget(_incomingTable);

      if (_incomingTable->columnCount() < 2)
        _incomingTable->setColumnCount(2);

      QTableWidgetItem *__colItem = new QTableWidgetItem();
      __colItem->setText(QApplication::translate("Form", "Property", 0, QApplication::UnicodeUTF8));
      _incomingTable->setHorizontalHeaderItem(0, __colItem);
      __colItem = new QTableWidgetItem();
      __colItem->setText(QApplication::translate("Form", "Value", 0, QApplication::UnicodeUTF8));
      _incomingTable->setHorizontalHeaderItem(1, __colItem);
      _incomingTable->verticalHeader()->hide();

      if (_incomingTable->rowCount() < 1)
          _incomingTable->setRowCount(0);
      
      if(_device != NULL )
        setIncomingTable(_device->getIncomingParametersAsString());

//      _incomingTable->setEnabled(false);
  
    }// Adding the incoming parameters table

    hboxLayout = new QHBoxLayout();
    QLabel* tmpLabel = new QLabel(this);
    tmpLabel->setText(QApplication::translate("Form", "URL:", 0, QApplication::UnicodeUTF8));
    hboxLayout->addWidget(tmpLabel);
    _urlText = new QLineEdit(this);
    _urlText->setObjectName(QString::fromUtf8("url"));
    hboxLayout->addWidget(_urlText);
    vboxLayout->addLayout(hboxLayout);

    hboxLayout = new QHBoxLayout();
    tmpLabel = new QLabel(this);
    tmpLabel->setText(QApplication::translate("Form", "Port:", 0, QApplication::UnicodeUTF8));
    hboxLayout->addWidget(tmpLabel);
    _portText = new QLineEdit(this);
    hboxLayout->addWidget(_portText);
    vboxLayout->addLayout(hboxLayout);

    hboxLayout = new QHBoxLayout();
    //tmpLabel = new QLabel(this);
    //tmpLabel->setText(QApplication::translate("Form", "TCP:", 0, QApplication::UnicodeUTF8));
    //hboxLayout->addWidget(tmpLabel);
    _directOption = new QRadioButton(QApplication::translate("Form", "Direct:", 0, QApplication::UnicodeUTF8),this);
    _directOption->setChecked(true);
    hboxLayout->addWidget(_directOption);
    _tcpOption = new QRadioButton(QApplication::translate("Form", "TCP:", 0, QApplication::UnicodeUTF8),this);
    _tcpOption->setChecked(false);
    hboxLayout->addWidget(_tcpOption);
    _udpOption = new QRadioButton(QApplication::translate("Form", "UDP:", 0, QApplication::UnicodeUTF8),this);
    _udpOption->setChecked(false);
    hboxLayout->addWidget(_udpOption);
    vboxLayout->addLayout(hboxLayout);

    hboxLayout = new QHBoxLayout();
    hboxLayout->setObjectName(QString::fromUtf8("hboxLayout"));

    btnConnect = new QPushButton(this);
    btnConnect->setObjectName(QString::fromUtf8("connect"));
    btnConnect->setEnabled(false);
    hboxLayout->addWidget(btnConnect);

    btnDisconnect = new QPushButton(this);
    btnDisconnect->setObjectName(QString::fromUtf8("disconnect"));
    btnDisconnect->setEnabled(false);
    hboxLayout->addWidget(btnDisconnect);
    vboxLayout->addLayout(hboxLayout);

    _urlText->setEnabled(false);
    _portText->setEnabled(false);
    _urlText->setText("localhost");
    _portText->setText("6500");
    btnConnect->setText(QApplication::translate("Form", "Connect", 0, QApplication::UnicodeUTF8));
    btnDisconnect->setText(QApplication::translate("Form", "Disconnect", 0, QApplication::UnicodeUTF8));

    if(_device != NULL ){
      connect(btnConnect, SIGNAL( clicked() ), this, SLOT( connectDevice() ) );
      connect(btnDisconnect, SIGNAL( clicked() ), this, SLOT( disconnectDevice() ) );
      connect(_device, SIGNAL(updated()), this, SLOT(updateIncomingTable()));
      connect(_directOption, SIGNAL(clicked()), this, SLOT(connectionMethod()));
      connect(_udpOption, SIGNAL(clicked()), this, SLOT(connectionMethod()));
      connect(_tcpOption, SIGNAL(clicked()), this, SLOT(connectionMethod()));
      btnConnect->setEnabled(true);
	  if( _device->isReadDirectly() )
		_directOption->setChecked(true);
	  else{
		_tcpOption->setChecked(true);
	    _directOption->setChecked(false);
		_directOption->setEnabled(false);
	  }
      connectionMethod();
    }
  }

  void DeviceWidget::connectionMethod(){
    if(_directOption->isChecked()){
      _urlText->setEnabled(false);
      _portText->setEnabled(false);
    }else{
      _urlText->setEnabled(true);
      _portText->setEnabled(true);
    }
  }

  bool DeviceWidget::addButton(string name, QObject *receiver, const char *member){
    if(receiver != NULL && member != NULL){
      QPushButton* tmp = new QPushButton((QWidget*)this);
      hboxLayout->addWidget(tmp);
      connect(tmp, SIGNAL( clicked() ), receiver, member);
      return true;
    }
    return false;
  }

  void DeviceWidget::connectDevice(){
    if( _device->connect(_urlText->text().toUtf8().constData(),
                         _portText->text().toUtf8().constData(),
                         _tcpOption->isChecked())){
      btnConnect->setEnabled(false);
      _directOption->setEnabled(false);
      _tcpOption->setEnabled(false);
      _udpOption->setEnabled(false);
      btnDisconnect->setEnabled(true);
      writeGUI("Connection active");
    }else
      writeGUI("Connection can not be established");
  }

  void DeviceWidget::disconnectDevice(){
    _device->disconnect();
    btnConnect->setEnabled(true);
    btnDisconnect->setEnabled(false);
    _directOption->setEnabled(true);
    _tcpOption->setEnabled(true);
    _udpOption->setEnabled(true);
    writeGUI("Connection disabled");
  }

  void DeviceWidget::updateIncomingTable(){
    if(_device != NULL){
      string s = _device->getIncomingParametersAsString();
      if(s.size()!=0){
			  QString content(s.c_str());
			  QStringList cont = content.split("|");
			  QStringList h,v;
			  QStringList::const_iterator iterator;
			  //QTableWidgetItem *item;
			  for (iterator = cont.constBegin(); iterator != cont.constEnd();
					  ++iterator){
				  h << (*iterator).toUtf8().constData();
				  ++iterator;
				  v << (*iterator).toUtf8().constData();
			  }
			  
			  int j=0;
			  for(iterator = h.constBegin(); iterator != h.constEnd(); ++iterator){
          for(int i=0; i < _incomingTable->rowCount(); i++)
            if( (*iterator).compare(_incomingTable->item(i,0)->text()) == 0){
              _incomingTable->item(i,1)->setText(v.at(j));
              break;
            }
				  j++;
			  }
		  }
      //writeGUI("Updating table" + s);
//      _updateTimer->start();
    }
  }

  bool DeviceWidget::setIncomingTable(string s){
		if(s.size()!=0){
      _incomingTable->setSortingEnabled(false);
			QString content(s.c_str());
			QStringList cont = content.split("|");
			QStringList h,v;
			QStringList::const_iterator iterator;
			QTableWidgetItem *item;
			for (iterator = cont.constBegin(); iterator != cont.constEnd();
					++iterator){
				h << (*iterator).toUtf8().constData();
				++iterator;
				v << (*iterator).toUtf8().constData();
			}
			_incomingTable->setRowCount(v.size());
			int i=0;
			for(iterator = v.constBegin(); iterator != v.constEnd(); ++iterator){
				item = new QTableWidgetItem((*iterator).toUtf8().constData());
				_incomingTable->setItem(i,1,item);
				item= new QTableWidgetItem(h.at(i));
        _incomingTable->setItem(i,0,item);
				//_incomingTable->setVerticalHeaderItem(i,item);
				i++;
			}
      //_incomingTable->sortItems(0);
      return true;
		}
		return false;
	}

}
